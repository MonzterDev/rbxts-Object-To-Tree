<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBX0769754DC07C4194A452FF3B3A505657">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">include</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBX27E934BA2761464DA56CFC6CAA0D607C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Promise</string>
				<string name="ScriptGuid">{0E67793B-D12C-4D28-BAD4-A2C65C0B6A02}</string>
				<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Return a Promise from the success or failure handler and it will be chained onto.

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::


	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(traceback, finallyHandler, resolve, reject)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, *or* cancelled.

	Returns a new promise chained from this promise.

	:::caution
	If the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `finally` or `done` will run in the case of cancellation.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Set a handler that will be called only if the Promise resolves or is cancelled. This method is similar to `finally`, except it doesn't catch rejections.

	:::caution
	`done` should be reserved specifically when you want to perform some operation after the Promise is finished (like `finally`), but you don't want to consume rejections (like in <a href="/roblox-lua-promise/lib/Examples.html#cancellable-animation-sequence">this example</a>). You should use `andThen` instead if you only care about the Resolved case.
	:::

	:::warning
	Like `finally`, if the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `done` and `finally` will run in the case of cancellation.
	:::

	Returns a new promise chained from this promise.

	@param doneHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:done(doneHandler)
	assert(doneHandler == nil or isCallable(doneHandler), string.format(ERROR_NON_FUNCTION, "Promise:done"))
	return self:_finally(debug.traceback(nil, 2), doneHandler, true)
end

--[=[
	Same as `andThenCall`, except for `done`.

	Attaches a `done` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:doneCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[=[
	Attaches a `done` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:doneReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:done(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXBB26EDB0B404495BB15D2CD10120E590">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RuntimeLib</string>
				<string name="ScriptGuid">{8F35BC89-4B6C-47EC-97B9-C69E83ADDC23}</string>
				<ProtectedString name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")

local OUTPUT_PREFIX = "roblox-ts: "
local NODE_MODULES = "node_modules"
local DEFAULT_SCOPE = "@rbxts"

local TS = {}

TS.Promise = Promise

local function isPlugin(context)
	return RunService:IsStudio() and context:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

function TS.getModule(context, scope, moduleName)
	-- legacy call signature
	if moduleName == nil then
		moduleName = scope
		scope = DEFAULT_SCOPE
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local object = context
	repeat
		local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)
		if nodeModulesFolder then
			local scopeFolder = nodeModulesFolder:FindFirstChild(scope)
			if scopeFolder then
				local module = scopeFolder:FindFirstChild(moduleName)
				if module then
					return module
				end
			end
		end
		object = object.Parent
	until object == nil

	error(OUTPUT_PREFIX .. "Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(context, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error(OUTPUT_PREFIX .. "Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[context] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  ⇒ " .. currentModule.Name
			end

			error(OUTPUT_PREFIX .. "Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				OUTPUT_PREFIX
				.. "Invalid module access! Do you have multiple TS runtimes trying to import this? "
				.. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[context] == module then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

local SIGN = 2 ^ 31
local COMPLEMENT = 2 ^ 32
local function bit_sign(num)
	-- Restores the sign after an unsigned conversion according to 2s complement.
	if bit32.btest(num, SIGN) then
		return num - COMPLEMENT
	else
		return num
	end
end

function TS.bit_lrsh(a, b)
	return bit_sign(bit32.arshift(a, b))
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(func, catch, finally)
	local err, traceback
	local success, exitType, returns = xpcall(
		func,
		function(errInner)
			err = errInner
			traceback = debug.traceback()
		end
	)
	if not success and catch then
		local newExitType, newReturns = catch(err, traceback)
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

return TS
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBXE24C764AE1864FF48ED6AF8ECA91F0C9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">node_modules</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXEC47EB6A9AEA4793BCD68EDA931E6B70">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">@rbxts</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXBF33707253764DF39D0C776C9CE6115A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">compiler-types</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX2AB4979E425B47D3B70B770432B4E793">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">package</string>
							<string name="ScriptGuid">{2C2E0F24-767A-43D9-8B67-3EB06A21A4C4}</string>
							<ProtectedString name="Source"><![CDATA[return {
	author = "roblox-ts",
	description = "",
	devDependencies = {
		["@rbxts/types"] = "^1.0.571",
		["@typescript-eslint/eslint-plugin"] = "^5.10.0",
		["@typescript-eslint/parser"] = "^5.10.0",
		eslint = "^8.7.0",
		["eslint-config-prettier"] = "^8.1.0",
		["eslint-plugin-no-autofix"] = "^1.2.3",
		["eslint-plugin-prettier"] = "^4.0.0",
		["eslint-plugin-simple-import-sort"] = "^8.0.0",
		prettier = "^2.2.1",
		typescript = "^4.2.3",
	},
	files = {"types/*.d.ts"},
	license = "MIT",
	main = "types/core.d.ts",
	name = "@rbxts/compiler-types",
	scripts = {
		eslint = "npx eslint \"types/**/*.d.ts\" --max-warnings 0",
	},
	types = "types/core.d.ts",
	version = "2.0.4-types.0",
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXA778C1A5A09545AF90CC7163F29708D5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">types</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXC8B06230D6CB437680B55ED412EE780A">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">cubic-bezier</string>
						<string name="ScriptGuid">{72D7B2F6-6E5E-40B6-B87D-E754D45224E4}</string>
						<ProtectedString name="Source"><![CDATA[-- Smooth Interpolation Curve Generator
-- @author Validark
-- @original https://github.com/gre/bezier-easing
-- 		Copyright (c) 2014 Gaëtan Renaudeau, MIT License (see bottom for full license)
-- @testsite http://cubic-bezier.com/
-- @testsite http://greweb.me/bezier-easing-editor/example/

-- Bezier.new(x1, y1, x2, y2)
-- @param numbers (x1, y1, x2, y2) The control points of your curve
-- @returns function(t [b, c, d])
--	@param number t the time elapsed [0, d]
--	@param number b beginning value being interpolated (default = 0)
--	@param number c change in value being interpolated (equivalent to: ending - beginning) (default = 1)
--	@param number d duration interpolation is occurring over (default = 1)

-- These values are established by empiricism with tests (tradeoff: performance VS precision)
local NEWTON_ITERATIONS = 4
local NEWTON_MIN_SLOPE = 0.001
local SUBDIVISION_PRECISION = 0.0000001
local SUBDIVISION_MAX_ITERATIONS = 10
local K_SPLINE_TABLE_SIZE = 11

local K_SAMPLE_STEP_SIZE = 1 / (K_SPLINE_TABLE_SIZE - 1)

local function Linear(t, b, c, d)
	if d ~= nil then t = t / d end
	return (c or 1)*math.clamp(t, 0, 1) + (b or 0)
end

local Bezier = {}

function Bezier.new(x1, y1, x2, y2)
	-- TS cannot (reasonably) protect against this
	if not (0 <= x1 and x1 <= 1 and 0 <= x2 and x2 <= 1) then error("The x values must be within range [0, 1]") end

	if x1 == y1 and x2 == y2 then
		return Linear
	end

	-- Precompute redundant values
	local e, f = 3*x1, 3*x2
	local g, h, i = 1 - f + e, f - 2*e, 3*(1 - f + e)
	local j, k = 2*h, 3*y1
	local l, m = 1 - 3*y2 + k, 3*y2 - 2*k

	-- Precompute samples table
	local SampleValues = {}
	for a = 0, K_SPLINE_TABLE_SIZE - 1 do
		local z = a*K_SAMPLE_STEP_SIZE
		SampleValues[a] = ((g*z + h)*z + e)*z -- CalcBezier
	end

	return function(t, b, c, d)
		if d ~= nil then t = t / d end
		t = math.clamp(t, 0, 1) -- Make sure the endpoints are correct

		local CurrentSample = K_SPLINE_TABLE_SIZE - 2

		for a = 1, CurrentSample do
			if SampleValues[a] > t then
				CurrentSample = a - 1
				break
			end
		end

		-- Interpolate to provide an initial guess for t
		local IntervalStart = CurrentSample*K_SAMPLE_STEP_SIZE
		local GuessForT = IntervalStart + K_SAMPLE_STEP_SIZE*(t - SampleValues[CurrentSample]) / (SampleValues[CurrentSample + 1] - SampleValues[CurrentSample])
		local InitialSlope = (i*GuessForT + j)*GuessForT + e

		if InitialSlope >= NEWTON_MIN_SLOPE then
			for NewtonRaphsonIterate = 1, NEWTON_ITERATIONS do
				local CurrentSlope = (i*GuessForT + j)*GuessForT + e
				if CurrentSlope == 0 then break end
				GuessForT = GuessForT - (((g*GuessForT + h)*GuessForT + e)*GuessForT - t) / CurrentSlope
			end
		elseif InitialSlope ~= 0 then
			local IntervalStep = IntervalStart + K_SAMPLE_STEP_SIZE

			for BinarySubdivide = 1, SUBDIVISION_MAX_ITERATIONS do
				GuessForT = IntervalStart + 0.5*(IntervalStep - IntervalStart)
				local BezierCalculation = ((g*GuessForT + h)*GuessForT + e)*GuessForT - t

				if BezierCalculation > 0 then
					IntervalStep = GuessForT
				else
					IntervalStart = GuessForT
					BezierCalculation = -BezierCalculation
				end

				if BezierCalculation <= SUBDIVISION_PRECISION then break end
			end
		end

		t = ((l*GuessForT + m)*GuessForT + k)*GuessForT
		return (c or 1)*t + (b or 0)
	end
end

return Bezier

--[[
Copyright (c) 2014 Gaëtan Renaudeau
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
--]]
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXEB2A5D3BED944EA9929764E73C45BDA9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">package</string>
							<string name="ScriptGuid">{663B3C54-B1CD-4527-AA5A-544FBC3A54D6}</string>
							<ProtectedString name="Source"><![CDATA[return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-Libraries/issues",
	},
	description = "A library for generating smooth two-dimensional interpolation curves",
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/cubic-bezier/README.md",
	keywords = {"bezier", "cubic-bezier", "curve", "interpolation", "interpolate", "easing", "ease", "lerp", "tween", "roblox"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/cubic-bezier",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/cubic-bezier",
	},
	scripts = {
		test = "echo \"Error: no test specified\" && exit 1",
	},
	types = "index.d.ts",
	version = "1.1.0",
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX6B703AAC07A24C39BB41924C3E9323D2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">cue</string>
						<string name="ScriptGuid">{A3A4E0C7-2745-4C09-9342-C8815316777C}</string>
						<ProtectedString name="Source"><![CDATA[-- The lightest Event library ever
-- Pretty straightforward
-- @author Validark

local Cue = {}
Cue.__index = Cue

function Cue.new()
	return setmetatable({}, Cue)
end

function Cue:go(...)
	for i = 1, #self do
		coroutine.resume(coroutine.create(self[i]), ...)
	end
end

function Cue:bind(Function)
	self[#self + 1] = Function
end

function Cue:unbind(Function)
	local n = #self

	for i = 1, n do
		if Function == self[i] then
			self[i] = self[n]
			self[n] = nil
			break
		end
	end
end

function Cue:unbindAll()
	for i = 1, #self do
		self[i] = nil
	end
end

return Cue
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXA0D20184849E4583B4F23E3F06AF4741">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">package</string>
							<string name="ScriptGuid">{0D4FB69F-1F9A-48B8-AFFC-30D0232C1D9A}</string>
							<ProtectedString name="Source"><![CDATA[return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-Libraries/issues",
	},
	description = "The fastest and lightest Event object ever made",
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/cue/README.md",
	keywords = {"Roblox", "TypeScript", "roblox-TS", "event", "signal", "connection"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/cue",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/cue",
	},
	scripts = {
		test = "echo \"Error: no test specified\" && exit 1",
	},
	types = "index.d.ts",
	version = "1.0.1",
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX8B3561465C2C49BFA4CF1D590CBCA8C0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">delay-spawn-wait</string>
						<string name="ScriptGuid">{0F51C35A-1EAD-4055-9105-6DF3632A61F5}</string>
						<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local function spawn(callback, ...)
    local bindable = Instance.new("BindableEvent")
    local length = select("#", ...)

    if length == 0 then
        bindable.Event:Connect(callback)
    else
        local args = { ... }
        bindable.Event:Connect(function()
            callback(table.unpack(args, 1, length))
        end)
    end

	bindable:Fire()
	bindable:Destroy()
end

-- uses a min-heap to achieve O(1) check operations and O(log(n)) remove/insert operations
local queue = {}
local len = 0

local connection -- the Heartbeat `RBXScriptConnection | nil`

local function heartbeatStep()
	local clockTick = os.clock()

	repeat
		local current = queue[1]
		if current == nil or current.endTime > clockTick then break end
		local done = len == 1

		if done then
			queue[1] = nil
			len = 0
			connection:Disconnect()
			connection = nil
		else
			local lastNode = queue[len]
			queue[len] = nil
			len = len - 1
			local targetIndex = 1

			while true do
				local childIndex = 2*targetIndex -- leftChild, but this might change to rightChild below
				if childIndex > len then break end
				local minChild = queue[childIndex]
				local rightChildIndex = childIndex + 1

				if rightChildIndex <= len then
					local rightChild = queue[rightChildIndex]
					if rightChild.endTime < minChild.endTime then
						childIndex = rightChildIndex
						minChild = rightChild
					end
				end

				if lastNode.endTime < minChild.endTime then break end
				queue[targetIndex] = minChild
				targetIndex = childIndex
			end

			queue[targetIndex] = lastNode
		end

		local args = current.args
		local callback = current.callback

		if typeof(callback) == "Instance" then
			if args then
				callback:Fire(os.clock() - current.startTime, table.unpack(args, 2, args[1]))
			else
				callback:Fire(os.clock() - current.startTime)
			end
		else
			local bindable = Instance.new("BindableEvent")

			if args then
				bindable.Event:Connect(function(elapsedTime)
					callback(elapsedTime, table.unpack(args, 2, args[1]))
				end)
			else
				bindable.Event:Connect(callback)
			end

			bindable:Fire(os.clock() - current.startTime)
			bindable:Destroy()
		end
	until done
end

local function delay(seconds, callback, ...)
	-- If seconds is nil, -INF, INF, NaN, or less than MINIMUM_DELAY, assume seconds is MINIMUM_DELAY.
	if seconds == nil or not (seconds > 0) or seconds == math.huge then
		seconds = 0
	end

	local startTime = os.clock()
	local endTime = startTime + seconds
	local length = select("#", ...)

	if connection == nil then -- first is nil when connection is nil
		connection = RunService.Heartbeat:Connect(heartbeatStep)
	end

	local node = {
		callback = callback,
		startTime = startTime,
		endTime = endTime,
		args = length > 0 and { length + 1, ... }
	}

	local targetIndex = len + 1
	len = targetIndex

	while true do
		local parentIndex = (targetIndex - targetIndex % 2) / 2
		if parentIndex < 1 then break end
		local parentNode = queue[parentIndex]
		if parentNode.endTime < node.endTime then break end
		queue[targetIndex] = parentNode
		targetIndex = parentIndex
	end

	queue[targetIndex] = node
end

local function wait(seconds)
    local bindable = Instance.new("BindableEvent")
    delay(seconds, bindable)
    local elapsedTime = bindable.Event:Wait()
    bindable:Destroy()
    return elapsedTime
end

return {
    spawn = spawn;
    delay = delay;
    wait = wait;
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX8CD184C52B4E4C63BF2D03AD8785449B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">package</string>
							<string name="ScriptGuid">{0693F7EE-EADD-41D6-99E6-1FE3C3C3FF5C}</string>
							<ProtectedString name="Source"><![CDATA[return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-Libraries/issues",
	},
	bundledDependencies = {},
	description = "Replacement for the default delay, spawn, and wait functions",
	files = {"init.lua", "index.d.ts", "README.md"},
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/delay-spawn-wait/README.md",
	keywords = {"yield", "wait", "spawn", "delay"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/delay-spawn-wait",
	peerDependencies = {
		["@rbxts/compiler-types"] = "^1.0.0-beta.15.0",
		["@rbxts/types"] = "^1.0.441",
	},
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/delay-spawn-wait",
	},
	scripts = {
	},
	types = "index.d.ts",
	version = "2.0.0",
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX68C0C8232A55487F9131110D3571F278">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">easing-functions</string>
						<string name="ScriptGuid">{AFD57341-35F2-4A28-9BC1-14D47D461D21}</string>
						<ProtectedString name="Source"><![CDATA[-- Prescribed Material design Beziers and optimized Robert Penner functions
-- @author Robert Penner

local Bezier = require(assert(script.Parent:FindFirstChild("cubic-bezier"), "[@rbxts/easing-functions] Please `npm install @rbxts/cubic-bezier` to use this library."))

-- @specs https://material.io/design/motion/speed.html#easing
local Sharp = Bezier.new(0.4, 0, 0.6, 1)
local Standard = Bezier.new(0.4, 0, 0.2, 1)
local Acceleration = Bezier.new(0.4, 0, 1, 1)
local Deceleration = Bezier.new(0, 0, 0.2, 1)

--[[
	Disclaimer for Robert Penner's Easing Equations license:

	TERMS OF USE - EASING EQUATIONS

	Open source under the BSD License.

	Copyright © 2001 Robert Penner
	All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	* Neither the name of the author nor the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
]]

-- For all easing functions:
-- t = elapsed time
-- b = beginning value
-- c = change in value same as: ending - beginning
-- d = duration (total time)

-- Where applicable
-- a = amplitude
-- p = period

local sin = math.sin
local cos = math.cos
local abs = math.abs
local asin = math.asin
local exp = math.exp

local SoftSpringpi = -3.2*3.1415926535897932
local Springpi = 2*SoftSpringpi

local function Linear(t, b, c, d)
	return c * t / d + b
end

local function Smooth(t, b, c, d)
	t = t / d
	return c * t * t * (3 - 2*t) + b
end

local function Smoother(t, b, c, d)
	t = t / d
	return c*t*t*t * (t * (6*t - 15) + 10) + b
end

-- Arceusinator's Easing Functions
local function RevBack(t, b, c, d)
	t = 1 - t / d
	return c*(1 - (sin(t*1.5707963267948966) + (sin(t*3.1415926535897932) * (cos(t*3.1415926535897932) + 1)*0.5))) + b
end

local function RidiculousWiggle(t, b, c, d)
	t = t / d
	return c*sin(sin(t*3.1415926535897932)*1.5707963267948966) + b
end

-- YellowTide's Easing Functions
local function Spring(t, b, c, d)
	t = t / d
	return (1 + (-exp(-6.9 * t) * cos(Springpi*t))) * c + b
end

local function SoftSpring(t, b, c, d)
	t = t / d
	return (1 + (-exp(-7.5 * t) * cos(SoftSpringpi*t))) * c + b
end
-- End of YellowTide's functions

local function InQuad(t, b, c, d)
	t = t / d
	return c * t * t + b
end

local function OutQuad(t, b, c, d)
	t = t / d
	return -c * t * (t - 2) + b
end

local function InOutQuad(t, b, c, d)
	t = t / d * 2

	if t < 1 then
		return c * 0.5 * t * t + b
	else
		return -c * 0.5 * ((t - 1) * (t - 3) - 1) + b
	end
end

local function OutInQuad(t, b, c, d)
	if t < d * 0.5 then
		t = 2 * t / d
		return -0.5 * c * t * (t - 2) + b
	else
		t = ((t * 2) - d) / d
		c = 0.5 * c
		return c * t * t + b + c
	end
end

local function InCubic(t, b, c, d)
	t = t / d
	return c * t * t * t + b
end

local function OutCubic(t, b, c, d)
	t = t / d - 1
	return c * (t * t * t + 1) + b
end

local function InOutCubic(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t + b
	else
		t = t - 2
		return c * 0.5 * (t * t * t + 2) + b
	end
end

local function OutInCubic(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * 0.5 * (t * t * t + 1) + b
	else
		t = ((t * 2) - d) / d
		c = c * 0.5
		return c * t * t * t + b + c
	end
end

local function InQuart(t, b, c, d)
	t = t / d
	return c * t * t * t * t + b
end

local function OutQuart(t, b, c, d)
	t = t / d - 1
	return -c * (t * t * t * t - 1) + b
end

local function InOutQuart(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t * t + b
	else
		t = t - 2
		return -c * 0.5 * (t * t * t * t - 2) + b
	end
end

local function OutInQuart(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		c = c * 0.5
		return -c * (t * t * t * t - 1) + b
	else
		t = ((t * 2) - d) / d
		c = c * 0.5
		return c * t * t * t * t + b + c
	end
end

local function InQuint(t, b, c, d)
	t = t / d
	return c * t * t * t * t * t + b
end

local function OutQuint(t, b, c, d)
	t = t / d - 1
	return c * (t * t * t * t * t + 1) + b
end

local function InOutQuint(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t * t * t + b
	else
		t = t - 2
		return c * 0.5 * (t * t * t * t * t + 2) + b
	end
end

local function OutInQuint(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * 0.5 * (t * t * t * t * t + 1) + b
	else
		t = ((t * 2) - d) / d
		c = c * 0.5
		return c * t * t * t * t * t + b + c
	end
end

local function InSine(t, b, c, d)
	return -c * cos(t / d * 1.5707963267948966) + c + b
end

local function OutSine(t, b, c, d)
	return c * sin(t / d * 1.5707963267948966) + b
end

local function InOutSine(t, b, c, d)
	return -c * 0.5 * (cos(3.1415926535897932 * t / d) - 1) + b
end

local function OutInSine(t, b, c, d)
	c = c * 0.5
	if t < d * 0.5 then
		return c * sin(t * 2 / d * 1.5707963267948966) + b
	else
		return -c * cos(((t * 2) - d) / d * 1.5707963267948966) + 2 * c + b
	end
end

local function InExpo(t, b, c, d)
	if t == 0 then
		return b
	else
		return c * 1024 ^ (t / d - 1) + b - c * 0.001
	end
end

local function OutExpo(t, b, c, d)
	if t == d then
		return b + c
	else
		return c * 1.001 * (1 - exp(-6.9314718055994531 * (t / d))) + b
	end
end

local function InOutExpo(t, b, c, d)
	t = t / d * 2

	if t == 0 then
		return b
	elseif t == 2 then
		return b + c
	elseif t < 1 then
		return c * 0.5 * 1024 ^ (t - 1) + b - c * 0.0005
	else
		return c * 0.50025 * (2 - exp(-6.9314718055994531 * (t - 1))) + b
	end
end

local function OutInExpo(t, b, c, d)
	c = c * 0.5
	if t < d * 0.5 then
		if t * 2 == d then
			return b + c
		else
			return c * 1.001 * (1 - exp(13.8629436111989062 * t / d)) + b
		end
	else
		if t * 2 - d == 0 then
			return b + c
		else
			return c * 1024 ^ ((t * 2 - d) / d - 1) + b + c - c * 0.001
		end
	end
end

local function InCirc(t, b, c, d)
	t = t / d
	return -c * ((1 - t * t) ^ 0.5 - 1) + b
end

local function OutCirc(t, b, c, d)
	t = t / d - 1
	return c * (1 - t * t) ^ 0.5 + b
end

local function InOutCirc(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return -c * 0.5 * ((1 - t * t) ^ 0.5 - 1) + b
	else
		t = t - 2
		return c * 0.5 * ((1 - t * t) ^ 0.5 + 1) + b
	end
end

local function OutInCirc(t, b, c, d)
	c = c * 0.5
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * (1 - t * t) ^ 0.5 + b
	else
		t = (t * 2 - d) / d
		return -c * ((1 - t * t) ^ 0.5 - 1) + b + c
	end
end

local function InElastic(t, b, c, d, a, p)
	t = t / d - 1
	if t == -1 then
		return b
	else
		if t == 0 then
			return b + c
		else
			p = p or d * 0.3
			local abs_c

			if c < 0 then
				abs_c = -c
			else
				abs_c = c
			end

			if a == nil or a < abs_c then
				return -(c * 1024 ^ t * sin((t * d - p * 0.25) * 6.2831853071795864 / p)) + b
			else
				return -(a * 1024 ^ t * sin((t * d - p / 6.2831853071795864 * asin(c/a)) * 6.2831853071795864 / p)) + b
			end
		end
	end
end

local function OutElastic(t, b, c, d, a, p)
	t = t / d
	if t == 0 then
		return b
	else
		if t == 1 then
			return b + c
		else
			p = p or d * 0.3
			local abs_c

			if c < 0 then
				abs_c = -c
			else
				abs_c = c
			end

			if a == nil or a < abs_c then
				return c * exp(-6.9314718055994531 * t) * sin((t * d - p * 0.25) * 6.2831853071795864 / p) + c + b
			else
				return a * exp(-6.9314718055994531 * t) * sin((t * d - p / 6.2831853071795864 * asin(c / a)) * 6.2831853071795864 / p) + c + b
			end
		end
	end
end

local function InOutElastic(t, b, c, d, a, p)
	if t == 0 then
		return b
	end

	t = t / d * 2 - 1

	if t == 1 then
		return b + c
	end

	p = p or d * 0.45
	a = a or 0

	local s
	local abs_c

	if c < 0 then
		abs_c = -c
	else
		abs_c = c
	end

	if a == nil or a < abs_c then
		a = c
		s = p * 0.25
	else
		s = p / 6.2831853071795864 * asin(c / a)
	end

	if t < 1 then
		return -0.5 * a * 1024 ^ t * sin((t * d - s) * 6.2831853071795864 / p) + b
	else
		return a * exp(-6.9314718055994531 * t) * sin((t * d - s) * 6.2831853071795864 / p ) * 0.5 + c + b
	end
end

local function OutInElastic(t, b, c, d, a, p)
	if t < d * 0.5 then
		return OutElastic(t * 2, b, c * 0.5, d, a, p)
	else
		return InElastic(t * 2 - d, b + c * 0.5, c * 0.5, d, a, p)
	end
end

local function InBack(t, b, c, d, s)
	s = s or 1.70158
	t = t / d
	return c * t * t * ((s + 1) * t - s) + b
end

local function OutBack(t, b, c, d, s)
	s = s or 1.70158
	t = t / d - 1
	return c * (t * t * ((s + 1) * t + s) + 1) + b
end

local function InOutBack(t, b, c, d, s)
	s = (s or 1.70158) * 1.525
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * (t * t * ((s + 1) * t - s)) + b
	else
		t = t - 2
		return c * 0.5 * (t * t * ((s + 1) * t + s) + 2) + b
	end
end

local function OutInBack(t, b, c, d, s)
	c = c * 0.5
	s = s or 1.70158
	if t < d * 0.5 then
		t = (t * 2) / d - 1
		return c * (t * t * ((s + 1) * t + s) + 1) + b
	else
		t = ((t * 2) - d) / d
		return c * t * t * ((s + 1) * t - s) + b + c
	end
end

local function OutBounce(t, b, c, d)
	t = t / d
	if t < 1 / 2.75 then
		return c * (7.5625 * t * t) + b
	elseif t < 2 / 2.75 then
		t = t - (1.5 / 2.75)
		return c * (7.5625 * t * t + 0.75) + b
	elseif t < 2.5 / 2.75 then
		t = t - (2.25 / 2.75)
		return c * (7.5625 * t * t + 0.9375) + b
	else
		t = t - (2.625 / 2.75)
		return c * (7.5625 * t * t + 0.984375) + b
	end
end

local function InBounce(t, b, c, d)
	return c - OutBounce(d - t, 0, c, d) + b
end

local function InOutBounce(t, b, c, d)
	if t < d * 0.5 then
		return InBounce(t * 2, 0, c, d) * 0.5 + b
	else
		return OutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b
	end
end

local function OutInBounce(t, b, c, d)
	if t < d * 0.5 then
		return OutBounce(t * 2, b, c * 0.5, d)
	else
		return InBounce(t * 2 - d, b + c * 0.5, c * 0.5, d)
	end
end

return {
	Standard = Standard;
	Deceleration = Deceleration;
	Acceleration = Acceleration;
	Sharp = Sharp;

	Linear = Linear;

	InSine = InSine;
	OutSine = OutSine;
	InOutSine = InOutSine;
	OutInSine = OutInSine;

	InBack = InBack;
	OutBack = OutBack;
	InOutBack = InOutBack;
	OutInBack = OutInBack;

	InQuad = InQuad;
	OutQuad = OutQuad;
	InOutQuad = InOutQuad;
	OutInQuad = OutInQuad;

	InQuart = InQuart;
	OutQuart = OutQuart;
	InOutQuart = InOutQuart;
	OutInQuart = OutInQuart;

	InQuint = InQuint;
	OutQuint = OutQuint;
	InOutQuint = InOutQuint;
	OutInQuint = OutInQuint;

	InBounce = InBounce;
	OutBounce = OutBounce;
	InOutBounce = InOutBounce;
	OutInBounce = OutInBounce;

	InElastic = InElastic;
	OutElastic = OutElastic;
	InOutElastic = InOutElastic;
	OutInElastic = OutInElastic;

	InCirc = InCirc;
	OutCirc = OutCirc;
	InOutCirc = InOutCirc;
	OutInCirc = OutInCirc;

	InCubic = InCubic;
	OutCubic = OutCubic;
	InOutCubic = InOutCubic;
	OutInCubic = OutInCubic;

	InExpo = InExpo;
	OutExpo = OutExpo;
	InOutExpo = InOutExpo;
	OutInExpo = OutInExpo;

	Smooth = Smooth;
	Smoother = Smoother;
	RevBack = RevBack;
	RidiculousWiggle = RidiculousWiggle;
	Spring = Spring;
	SoftSpring = SoftSpring;
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX4344ADA6077F4414A0C96D43ECD390F6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">package</string>
							<string name="ScriptGuid">{A2F72986-B18F-45E7-81D8-7F679B2814D1}</string>
							<ProtectedString name="Source"><![CDATA[return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-libraries/issues",
	},
	bundledDependencies = {},
	dependencies = {
		["@rbxts/cubic-bezier"] = "^1.0.2",
	},
	description = "A bunch of reuseable Easing Functions, including those from the Material Design specification and Robert Penner.",
	files = {"init.lua", "index.d.ts", "README.md"},
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/easing-functions/README.md",
	keywords = {"bezier", "cubic-bezier", "curve", "interpolation", "interpolate", "easing", "ease", "lerp", "tween", "roblox"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/easing-functions",
	peerDependencies = {
		["@rbxts/cubic-bezier"] = "^1.0.2",
	},
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/easing-functions",
	},
	scripts = {
		test = "echo \"Error: no test specified\" && exit 1",
	},
	typings = "index.d.ts",
	version = "1.1.0",
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXA9075C8CDC5E4860AEB949C8100CACD2">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">lerp-functions</string>
						<string name="ScriptGuid">{9143B5FE-654C-44DB-8935-C5CC68018D74}</string>
						<ProtectedString name="Source"><![CDATA[local function sortByTime(a, b)
	return a.Time < b.Time
end

-- Mostly ripped off from https://github.com/Fraktality/anim/blob/master/anim.lua
-- Copyright 2017 Parker Stebbins <parker@fractality.io>
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software
-- and associated documentation files (the "Software"), to deal in the Software without
-- restriction, including without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
-- Software is furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or
-- substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
-- BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--
local Lerps = {}

-- bool
function Lerps.boolean(v0, v1)
	return function(t)
		if t < 0.5 then
			return v0
		else
			return v1
		end
	end
end

-- number
function Lerps.number(v0, v1)
	local dv = v1 - v0
	return function(t)
		return v0 + dv*t
	end
end

do -- Color3
	local C3 = Color3.new
	local black = C3(0, 0, 0)

	function Lerps.Color3(c0, c1)
		local u0, v0, u1, v1, l0, l1

		-- Convert from linear RGB to scaled CIELUV (RgbToLuv13)
		local r, g, b = c0.r, c0.g, c0.b
		-- Apply inverse gamma correction

		if r < 0.0404482362771076 then
			r = r / 12.92
		else
			r = 0.87941546140213*(r + 0.055)^2.4
		end

		if g < 0.0404482362771076 then
			g = g / 12.92
		else
			g = 0.87941546140213*(g + 0.055)^2.4
		end

		if b < 0.0404482362771076 then
			b = b / 12.92
		else
			b = 0.87941546140213*(b + 0.055)^2.4
		end

		-- sRGB->XYZ->CIELUV
		local y = 0.2125862307855956*r + 0.71517030370341085*g + 0.0722004986433362*b
		local z = 3.6590806972265883*r + 11.4426895800574232*g + 4.1149915024264843*b

		if y > 0.008856451679035631 then
			l0 = 116*y^(1/3) - 16
		else
			l0 = 903.296296296296*y
		end

		if z > 1e-15 then
			u0, v0 = l0*(0.9257063972951867*r - 0.8333736323779866*g - 0.09209820666085898*b)/z, l0*(9*y/z - 0.46832)
		else
			u0, v0 = -0.19783*l0, -0.46832*l0
		end

		-- Convert from linear RGB to scaled CIELUV (RgbToLuv13)
		r, g, b = c1.r, c1.g, c1.b
		-- Apply inverse gamma correction

		if r < 0.0404482362771076 then
			r = r / 12.92
		else
			r = 0.87941546140213*(r + 0.055)^2.4
		end

		if g < 0.0404482362771076 then
			g = g / 12.92
		else
			g = 0.87941546140213*(g + 0.055)^2.4
		end

		if b < 0.0404482362771076 then
			b = b / 12.92
		else
			b = 0.87941546140213*(b + 0.055)^2.4
		end

		-- sRGB->XYZ->CIELUV
		y = 0.2125862307855956*r + 0.71517030370341085*g + 0.0722004986433362*b
		z = 3.6590806972265883*r + 11.4426895800574232*g + 4.1149915024264843*b

		if y > 0.008856451679035631 then
			l1 = 116*y^(1/3) - 16
		else
			l1 = 903.296296296296*y
		end

		if z > 1e-15 then
			u1, v1 = l1*(0.9257063972951867*r - 0.8333736323779866*g - 0.09209820666085898*b)/z, l1*(9*y/z - 0.46832)
		else
			u1, v1 = -0.19783*l1, -0.46832*l1
		end

		return function(t)
			local l = (1 - t)*l0 + t*l1
			if l < 0.0197955 then
				return black
			end

			local u = ((1 - t)*u0 + t*u1)/l + 0.19783
			local v = ((1 - t)*v0 + t*v1)/l + 0.46832

			local y = (l + 16)/116

			if y > 0.206896551724137931 then
				y = y*y*y
			else
				y = 0.12841854934601665*y - 0.01771290335807126
			end

			local x = y*u/v
			local z = y*((3 - 0.75*u)/v - 5)

			local r =  7.2914074*x - 1.5372080*y - 0.4986286*z
			local g = -2.1800940*x + 1.8757561*y + 0.0415175*z
			local b =  0.1253477*x - 0.2040211*y + 1.0569959*z

			if r < 0 and r < g and r < b then
				r, g, b = 0, g - r, b - r
			elseif g < 0 and g < b then
				r, g, b = r - g, 0, b - g
			elseif b < 0 then
				r, g, b = r - b, g - b, 0
			end

			if r < 3.1306684425e-3 then
				r = 12.92*r
			else
				r = 1.055*r^(1 / 2.4) - 0.055
			end

			if g < 3.1306684425e-3 then
				g = 12.92*g
			else
				g = 1.055*g^(1 / 2.4) - 0.055
			end

			if b < 3.1306684425e-3 then
				b = 12.92*b
			else
				b = 1.055*b^(1 / 2.4) - 0.055
			end

			if r < 0 then
				r = 0
			elseif r > 1 then
				r = 1
			end

			if g < 0 then
				g = 0
			elseif g > 1 then
				g = 1
			end

			if b < 0 then
				b = 0
			elseif b > 1 then
				b = 1
			end

			return C3(r, g, b)
		end
	end
end

do -- string
	local s_match = string.match
	local s_format = string.format
	local atof = tonumber

	function Lerps.string(v0, v1)
		local n0, d do
			local sign0, h0, m0, s0 = s_match(v0, '^([+-]?)(%d*):[+-]?(%d*):[+-]?(%d*)$')
			local sign1, h1, m1, s1 = s_match(v1, '^([+-]?)(%d*):[+-]?(%d*):[+-]?(%d*)$')
			if sign0 and sign1 then
				n0       = 3600*(atof(h0) or 0) + 60*(atof(m0) or 0) + (atof(s0) or 0)
				local n1 = 3600*(atof(h1) or 0) + 60*(atof(m1) or 0) + (atof(s1) or 0)
				if sign0 == '-' then
					n0 = -n0
				end
				d = (43200 + (sign1 ~= '-' and n1 or -n1) - n0)%86400 - 43200
			else
				error('Invalid TimeOfDay string', 4)
			end
		end

		return function(t)
			local fs = (n0 + d*t)%86400
			local s = fs > 0 and fs or -fs
			return s_format(
				fs < 0 and '-%.2u:%.2u:%.2u' or '%.2u:%.2u:%.2u',
				(s - s%3600)/3600,
				(s%3600 - s%60)/60,
				s%60
			)
		end
	end
end

do -- CFrame
	local Slerp = CFrame.new().lerp
	function Lerps.CFrame(v0, v1)
		return function(t)
			return Slerp(v0, v1, t)
		end
	end
end

do -- NumberRange
	local NR = NumberRange.new
	function Lerps.NumberRange(v0, v1)
		local min0, max0 = v0.Min, v0.Max
		local dmin, dmax = v1.Min - min0, v1.Max - max0
		v0, v1 = nil, nil
		return function(t)
			return NR(min0 + t*dmin, max0 + t*dmax)
		end
	end
end

do -- NumberSequenceKeypoint
	local NSK = NumberSequenceKeypoint.new
	function Lerps.NumberSequenceKeypoint(v0, v1)
		local t0, v0, e0 = v0.Time, v0.Value, v0.Envelope
		local dt, dv, de = v1.Time - t0, v1.Value - v0, v1.Envelope - e0
		v1 = nil
		return function(t)
			return NSK(t0 + t*dt, v0 + t*dv, e0 + t*de)
		end
	end
end

do -- PhysicalProperties
	local PP = PhysicalProperties.new
	function Lerps.PhysicalProperties(v0, v1)
		local d0, e0, ew0, f0, fw0 =
			v0.Density,
			v0.Elasticity,
			v0.ElasticityWeight,
			v0.Friction,
			v0.FrictionWeight
		local dd, de, dew, df, dfw =
			v1.Density - d0,
			v1.Elasticity - e0,
			v1.ElasticityWeight - ew0,
			v1.Friction - f0,
			v1.FrictionWeight - fw0
		v0, v1 = nil, nil
		return function(t)
			return PP(d0 + t*dd, e0 + t*de, ew0 + t*dew, f0 + t*df, fw0 + t*dfw)
		end
	end
end

do -- Ray
	local R = Ray.new
	local V3 = Vector3.new
	function Lerps.Ray(v0, v1)
		local o0, d0, o1, d1 =
			v0.Origin, v0.Direction,
			v1.Origin, v1.Direction
		local ox0, oy0, oz0, dx0, dy0, dz0, dx1, dy1, dz1 =
			o0.x, o0.y, o0.z,
			d0.x, d0.y, d0.z,
			d1.x, d1.y, d1.z
		local dox, doy, doz, ddx, ddy, ddz =
			o1.x - ox0, o1.y - oy0, o1.z - oz0,
			d1.x - dx0, d1.y - dy0, d1.z - dz0
		v0, v1, o0, d0, o1, d1 = nil, nil, nil, nil, nil, nil
		return function(t)
			return R(
				V3(ox0 + t*dox, oy0 + t*doy, oz0 + t*doz),
				V3(dx0 + t*ddx, dy0 + t*ddy, dz0 + t*ddz)
			)
		end
	end
end

do
	newRect = Rect.new

	function Lerps.Rect(v0, v1)
		local sc, of = v0.Min.X, v0.Min.Y
		local dsc, dof = v1.Min.X - sc, v1.Min.Y - of
		local sc2, of2 = v0.Max.X, v0.Max.Y
		local dsc2, dof2 = v1.Max.X - sc2, v1.Max.Y - of2
		v0, v1 = nil, nil

		return function(t)
			return newRect(
				sc + t*dsc, of + t*dof,
				sc2 + t*dsc2, of2 + t*dof2
			)
		end
	end
end

do -- UDim
	local UD = UDim.new
	function Lerps.UDim(v0, v1)
		local sc, of = v0.Scale, v0.Offset
		local dsc, dof = v1.Scale - sc, v1.Offset - of
		v0, v1 = nil, nil
		return function(t)
			return UD(sc + t*dsc, of + t*dof)
		end
	end
end

do -- UDim2
	local Lerp = UDim2.new().Lerp
	function Lerps.UDim2(v0, v1)
		return function(t)
			return Lerp(v0, v1, t)
		end
	end
end

do -- Vector2
	local V2 = Vector2.new
	function Lerps.Vector2(v0, v1)
		local x, y = v0.x, v0.y
		local dx, dy = v1.x - x, v1.y - y
		v0, v1 = nil, nil
		return function(t)
			return V2(x + t*dx, y + t*dy)
		end
	end
end

do -- Vector3
	local V3 = Vector3.new
	function Lerps.Vector3(v0, v1)
		local x, y, z = v0.x, v0.y, v0.z
		local dx, dy, dz = v1.x - x, v1.y - y, v1.z - z
		v0, v1 = nil, nil
		return function(t)
			return V3(x + t*dx, y + t*dy, z + t*dz)
		end
	end
end

do -- ColorSequence
	local newColorSequence = ColorSequence.new
	local Color3Lerp = Lerps.Color3

	function Lerps.ColorSequence(start, finish)
		local l1 = Color3Lerp(start[1], finish[1])
		local l2 = Color3Lerp(start[2], finish[2])

		return function(alpha)
			return newColorSequence(l1(alpha), l2(alpha))
		end
	end
end

do -- Region3
	local newRegion3 = Region3.new
	local newVector3 = Vector3.new

	function Lerps.Region3(start, finish) -- @author Sharksie
		local start1 = start.CFrame * (-start.Size*0.5)
		local start2 = start.CFrame * ( start.Size*0.5)

		local finish1 = finish.CFrame * (-finish.Size*0.5)
		local finish2 = finish.CFrame * ( finish.Size*0.5)

		local change1 = finish1 - start1
		local change2 = finish2 - start2

		return function(alpha)
			local imin = start1 + alpha * change1
			local imax = start2 + alpha * change2

			local iminx = imin.x
			local imaxx = imax.x

			local iminy = imin.y
			local imaxy = imax.y

			local iminz = imin.z
			local imaxz = imax.z

			local x1, x2
			local y1, y2
			local z1, z2

			if iminx < imaxx then
				x1 = iminx
				x2 = imaxx
			else
				x1 = imaxx
				x2 = iminx
			end

			if iminy < imaxy then
				y1 = iminy
				y2 = imaxy
			else
				y1 = imaxy
				y2 = iminy
			end

			if iminz < imaxz then
				z1 = iminz
				z2 = imaxz
			else
				z1 = imaxz
				z2 = iminz
			end

			return newRegion3(
				newVector3(x1, y1, z1),
				newVector3(x2, y2, z2)
			)
		end
	end;
end

do
	function Lerps.NumberSequence(start, finish)
		return function(alpha)
			-- @author Sharksie

			-- For each point on each line, find the values of the other sequence at that point in time through interpolation
			-- 	then interpolate between the known value and the learned value
			-- 	then use that value to create a new keypoint at the time
			-- 	then build a new sequence using all the keypoints generated

			local keypoints = {}
			local addedTimes = {}

			for i, ap in next, start.Keypoints do
				local closestAbove, closestBelow

				for i, bp in next, finish.Keypoints do
					if bp.Time == ap.Time then
						closestAbove, closestBelow = bp, bp
						break
					elseif bp.Time < ap.Time and (closestBelow == nil or bp.Time > closestBelow.Time) then
						closestBelow = bp
					elseif bp.Time > ap.Time and (closestAbove == nil or bp.Time < closestAbove.Time) then
						closestAbove = bp
					end
				end

				local bValue, bEnvelope
				if closestAbove == closestBelow then
					bValue, bEnvelope = closestAbove.Value, closestAbove.Envelope
				else
					local p = (ap.Time - closestBelow.Time)/(closestAbove.Time - closestBelow.Time)
					bValue = (closestAbove.Value - closestBelow.Value)*p + closestBelow.Value
					bEnvelope = (closestAbove.Envelope - closestBelow.Envelope)*p + closestBelow.Envelope
				end
				local interValue = (bValue - ap.Value)*alpha + ap.Value
				local interEnvelope = (bEnvelope - ap.Envelope)*alpha + ap.Envelope
				local interp = NumberSequenceKeypoint.new(ap.Time, interValue, interEnvelope)

				table.insert(keypoints, interp)

				addedTimes[ap.Time] = true
			end

			for i, bp in next, finish.Keypoints do
				if not addedTimes[bp.Time] then
					local closestAbove, closestBelow

					for i, ap in next, start.Keypoints do
						if ap.Time == bp.Time then
							closestAbove, closestBelow = ap, ap
							break
						elseif ap.Time < bp.Time and (closestBelow == nil or ap.Time > closestBelow.Time) then
							closestBelow = ap
						elseif ap.Time > bp.Time and (closestAbove == nil or ap.Time < closestAbove.Time) then
							closestAbove = ap
						end
					end

					local aValue, aEnvelope
					if closestAbove == closestBelow then
						aValue, aEnvelope = closestAbove.Value, closestAbove.Envelope
					else
						local p = (bp.Time - closestBelow.Time)/(closestAbove.Time - closestBelow.Time)
						aValue = (closestAbove.Value - closestBelow.Value)*p + closestBelow.Value
						aEnvelope = (closestAbove.Envelope - closestBelow.Envelope)*p + closestBelow.Envelope
					end
					local interValue = (bp.Value - aValue)*alpha + aValue
					local interEnvelope = (bp.Envelope - aEnvelope)*alpha + aEnvelope
					local interp = NumberSequenceKeypoint.new(bp.Time, interValue, interEnvelope)

					table.insert(keypoints, interp)
				end
			end

			table.sort(keypoints, sortByTime)

			return NumberSequence.new(keypoints)
		end
	end
end

return Lerps
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXFB3BF92BE94146EEB486594B62DC1509">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">package</string>
							<string name="ScriptGuid">{C34C8ABC-F987-4349-9672-2CC1A3B4B5FC}</string>
							<ProtectedString name="Source"><![CDATA[return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-Libraries/issues",
	},
	dependencies = {
		["@rbxts/types"] = "^1.0.227",
	},
	description = "Interpolation functions",
	files = {"init.lua", "index.d.ts", "README.md"},
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/lerp-functions/README.md",
	keywords = {"bezier", "cubic-bezier", "curve", "interpolation", "interpolate", "easing", "ease", "lerp", "tween", "roblox"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/lerp-functions",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/lerp-functions",
	},
	scripts = {
		test = "echo \"Error: no test specified\" && exit 1",
	},
	types = "index.d.ts",
	version = "1.0.2",
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXE3958E11F8AA461E82A5D3E8B1350DB0">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">tween</string>
						<string name="ScriptGuid">{FFE90562-8F39-4A86-B95D-373036961F3E}</string>
						<ProtectedString name="Source"><![CDATA[local Lerps = require(assert(script.Parent:FindFirstChild("lerp-functions"), "[@rbxts/tween] Please install @rbxts/lerp-functions to use this library."))

local Tween = {
	Running = false;
	ElapsedTime = 0;
}
Tween.__index = Tween

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local RenderStepped = RunService.RenderStepped

function Tween:Play()
	if not self.Running then
		local RenderEvent

		if self.ValueType == "CFrame" then
			RenderEvent = RenderStepped
		else
			RenderEvent = Heartbeat
		end

		self.Connection = RenderEvent:Connect(self.Interpolator)
		self.Running = true
	end

	return self
end

function Tween:Pause()
	if self.Running then
		self.Connection:Disconnect()
		self.Running = false
	end

	return self
end

function Tween:Cancel()
	self.ElapsedTime = 0
	return self:Pause()
end

function Tween:Wait()
	local RenderEvent

	if self.ValueType == "CFrame" then
		RenderEvent = RenderStepped
	else
		RenderEvent = Heartbeat
	end

	while self.Running do RenderEvent:Wait() end
	return self
end

local function MakeTween(Duration, EasingFunction, Callback, InitialValue, EndValue, v1, v2)
	if InitialValue == nil then
		InitialValue = 0
		EndValue = 1
	end

	local ValueType = typeof(InitialValue)
	local LerpFunction = Lerps[ValueType](InitialValue, EndValue)

	local self = setmetatable({
		Duration = Duration;
		ValueType = ValueType;
	}, Tween)

	function self.Interpolator(Step)
		local ElapsedTime = self.ElapsedTime + Step
		self.ElapsedTime = ElapsedTime

		if Duration > ElapsedTime then
			-- Because of the way doubles are implemented,
			-- they can hold more unique values between 0 and 1 than any other numbers.
			-- To take advantage of this precision, we shouldn't try to get smart about
			-- changing the beginning/change parameters here
			Callback(LerpFunction(EasingFunction(ElapsedTime, 0, 1, Duration, v1, v2)))
		else
			Callback(EndValue)
			self:Pause()
		end
	end

	return self:Play()
end

return {
	Tween = MakeTween;
	default = MakeTween;
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX6A8E3C1C63234888BAC0EFDB46AF2326">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">package</string>
							<string name="ScriptGuid">{EE03E6FE-5143-47C8-9DF5-452033861522}</string>
							<ProtectedString name="Source"><![CDATA[return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-Libraries/issues",
	},
	bundledDependencies = {},
	dependencies = {
		["@rbxts/cubic-bezier"] = "^1.0.2",
		["@rbxts/easing-functions"] = "^1.0.0",
		["@rbxts/lerp-functions"] = "^1.0.0",
	},
	description = "A library for writing efficient, simple interpolation code",
	devDependencies = {
		["@rbxts/compiler-types"] = "^2.0.2-types.0",
		["@rbxts/types"] = "^1.0.641",
	},
	files = {"init.lua", "index.d.ts", "README.md"},
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/tween/README.md",
	keywords = {"bezier", "cubic-bezier", "curve", "interpolation", "interpolate", "easing", "ease", "lerp", "tween", "roblox"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/tween",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/tween",
	},
	scripts = {
		test = "echo \"Error: no test specified\" && exit 1",
	},
	types = "index.d.ts",
	version = "1.0.5",
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXF3A8B380875E45B8A9A793D5DD25FBD8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">types</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXA07F8C7DDA1B4597A7A33528B153DF67">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">include</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX992A0F7631AB4C02952EBE884E83E379">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">generated</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX44154838A0914803B0AB706E744DCA1F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">package</string>
							<string name="ScriptGuid">{0F96A45F-03C2-4D17-B2AA-C469E229213E}</string>
							<ProtectedString name="Source"><![CDATA[return {
	author = "roblox-ts",
	bugs = {
		url = "https://github.com/roblox-ts/types/issues",
	},
	dependencies = {
	},
	description = "TypeScript typings for the Roblox platform. Partially handwritten and partially automatically generated.",
	homepage = "https://github.com/roblox-ts/types#readme",
	keywords = {"types", "Roblox", "typescript"},
	license = "MIT",
	main = "include/roblox.d.ts",
	name = "@rbxts/types",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/roblox-ts/types.git",
	},
	scripts = {
	},
	types = "include/roblox.d.ts",
	version = "1.0.646",
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="ModuleScript" referent="RBXCEF3BB65FEF34997AD73C6EBA1C31D36">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">apiDump</string>
			<string name="ScriptGuid">{D41A1121-ED7D-47A3-B80A-B9226CC15FEA}</string>
			<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local TS = require(script.Parent.include.RuntimeLib)
local Feedback = TS.import(script, script.Parent, "feedback")
local HttpService = game:GetService("HttpService")
local apiDump
return function()
	if apiDump then
		return apiDump
	else
		Feedback.new("Fetching API data...")
		-- alternative "https://anaminus.github.io/rbx/json/api/latest.json"
		local request = { pcall(function()
			return HttpService:GetAsync("https://raw.githubusercontent.com/CloneTrooper1019/Roblox-Client-Watch/roblox/API-Dump.json")
		end) }
		if request[1] then
			local apiRequest = { pcall(function()
				return HttpService:JSONDecode(request[2])
			end) }
			if apiRequest[1] then
				local dumpMap = {}
				for _, rbxClass in apiRequest[2].Classes do
					local _superclass = rbxClass.Superclass
					local superclass = dumpMap[_superclass]
					if superclass then
						for _1, rbxMember in superclass.Members do
							table.insert(rbxClass.Members, rbxMember)
						end
					end
					local _name = rbxClass.Name
					dumpMap[_name] = rbxClass
				end
				apiDump = dumpMap
				return apiDump
			else
				Feedback.new("[FATAL] Failed to decode API data.")
			end
		else
			Feedback.new("Failed to fetch API data. Please enable HttpService.HttpEnabled.")
		end
	end
end
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ModuleScript" referent="RBXE387E1EFFD9A470AAA269A0F00FD74FE">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">config</string>
			<string name="ScriptGuid">{2323DBF7-5FA3-4FE8-B82D-7E0670E44C3C}</string>
			<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local ICON_ID = 3561078226
local PLUGIN_NAME = "roblox-ts-object-to-tree"
local PLUGIN_DESCRIPTION = "A tool for converting instances to their TS tree form. Ignores all instances with name collisions."
local IO_SERVE_URL = "http://localhost:33333"
local OPTIONS = { "TS types", "Rojo-esque tree", "Instantiation code", "Roact TSX code" }
local DEFAULT_SETTING = OPTIONS[4]
return {
	ICON_ID = ICON_ID,
	PLUGIN_NAME = PLUGIN_NAME,
	PLUGIN_DESCRIPTION = PLUGIN_DESCRIPTION,
	IO_SERVE_URL = IO_SERVE_URL,
	OPTIONS = OPTIONS,
	DEFAULT_SETTING = DEFAULT_SETTING,
}
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ModuleScript" referent="RBX111AC22430DB4E59A85D836B893BC78D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">feedback</string>
			<string name="ScriptGuid">{EC403B27-75D1-4783-BF65-8979FF532446}</string>
			<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local TextService = game:GetService("TextService")
local TEXT_SIZE = 18
local TEXT_FONT = Enum.Font.SourceSans
-- * A lightweight feedback system
local _class
do
	local Feedback = setmetatable({}, {
		__tostring = function()
			return "Feedback"
		end,
	})
	Feedback.__index = Feedback
	function Feedback.new(...)
		local self = setmetatable({}, Feedback)
		return self:constructor(...) or self
	end
	function Feedback:constructor(text)
		if Feedback.currentFeedback then
			Feedback.currentFeedback.feedbackScreen:Destroy()
		end
		local feedbackScreen = Instance.new("ScreenGui")
		feedbackScreen.Name = "FeedbackScreen"
		local feedbackText = Instance.new("TextLabel")
		feedbackText.AnchorPoint = Vector2.new(0.5, 0.5)
		feedbackText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		feedbackText.BorderSizePixel = 0
		feedbackText.Position = UDim2.new(0.5, 0, 0.5, 0)
		feedbackText.Font = TEXT_FONT
		feedbackText.Text = text
		feedbackText.TextSize = TEXT_SIZE
		feedbackText.Size = UDim2.new(0, TextService:GetTextSize(text, TEXT_SIZE, TEXT_FONT, Vector2.new(math.huge, math.huge)).X + 36, 0, 50)
		feedbackText.Parent = feedbackScreen
		feedbackScreen.Parent = game:GetService("CoreGui")
		self.feedbackScreen = feedbackScreen
		Feedback.currentFeedback = self
		delay(5, function()
			if Feedback.currentFeedback == self then
				feedbackScreen:Destroy()
				Feedback.currentFeedback = nil
			end
		end)
	end
	_class = Feedback
end
return _class
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ModuleScript" referent="RBX9B0E3CA5984848B1B26A430A7984DD59">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">formatValue</string>
			<string name="ScriptGuid">{6EA2C0FB-1E5B-4F9C-8FBB-1A3C105E0189}</string>
			<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local POSITION_PRECISION = 0.001
local ORIENTATION_PRECISION = 0.001
local function round(number, place)
	if place == nil then
		place = 1
	end
	return math.floor(number / place + 0.5) * place
end
--[[
	*
	* Returns a string representation of a number that can perfectly reproduce the number with a `tonumber` call
	* @param n the number you wish to have a string representation of
]]
local function getSignificantDigits(n)
	local str = tostring(n)
	if tonumber(str) == n then
		return str
	end
	do
		local i = 15
		local _shouldIncrement = false
		while true do
			if _shouldIncrement then
				i += 1
			else
				_shouldIncrement = true
			end
			if not (i <= 99) then
				break
			end
			local _exp = "%." .. (tostring(i) .. "g")
			local _n = n
			str = string.format(_exp, _n)
			if tonumber(str) == n then
				return str
			end
		end
	end
	return error("Couldn't reproduce accurate number for " .. tostring(n))
end
local function formatValue(value)
	local _value = value
	local _exp = typeof(_value)
	repeat
		local _fallthrough = false
		if _exp == "Axes" then
			return "new Axes(" .. ((string.gsub(tostring(value), "(%u)(,?)", "Enum.Axis.%1%2")) .. ")")
		end
		if _exp == "BrickColor" then
			return 'new BrickColor("' .. (value.Name .. '")')
		end
		if _exp == "CFrame" then
			-- this is admittedly a stupid algorithm.
			-- if you have a problem with it, submit a PR
			-- https://github.com/Validark/rbxts-Object-To-Tree
			local part = Instance.new("Part")
			part.CFrame = value
			local position = part.Position
			local orientation = part.Orientation
			part:Destroy()
			return "CFrame.fromOrientation(math.rad(" .. (tostring(round(orientation.X, ORIENTATION_PRECISION)) .. ("), math.rad(" .. (tostring(round(orientation.Y, ORIENTATION_PRECISION)) .. ("), math.rad(" .. (tostring(round(orientation.Z, ORIENTATION_PRECISION)) .. (")) + new Vector3(" .. (tostring(round(position.X, POSITION_PRECISION)) .. (", " .. (tostring(round(position.Y, POSITION_PRECISION)) .. (", " .. (tostring(round(position.Z, POSITION_PRECISION)) .. ")")))))))))))
		end
		if _exp == "Color3" then
			local _binding = value
			local R = _binding.R
			local G = _binding.G
			local B = _binding.B
			return "Color3.fromRGB(" .. (tostring(round(255 * R)) .. (", " .. (tostring(round(255 * G)) .. (", " .. (tostring(round(255 * B)) .. ")")))))
		end
		if _exp == "ColorSequence" then
			local _exp_1 = value.Keypoints
			-- ▼ ReadonlyArray.map ▼
			local _newValue = table.create(#_exp_1)
			for _k, _v in _exp_1 do
				_newValue[_k] = formatValue(_v, _k - 1, _exp_1)
			end
			-- ▲ ReadonlyArray.map ▲
			return "new ColorSequence([" .. (table.concat(_newValue, ", ") .. "])")
		end
		if _exp == "ColorSequenceKeypoint" then
			local _binding = value
			local time = _binding.Time
			local color = _binding.Value
			return "new ColorSequenceKeypoint(" .. (formatValue(time) .. (", " .. (formatValue(color) .. ")")))
		end
		if _exp == "DockWidgetPluginGuiInfo" then
			local _binding = value
			local floatingXSize = _binding.FloatingXSize
			local floatingYSize = _binding.FloatingYSize
			local minHeight = _binding.MinHeight
			local minWidth = _binding.MinWidth
			local initialDockState = _binding.InitialDockState
			local initialEnabled = _binding.InitialEnabled
			local initialEnabledShouldOverrideRestore = _binding.InitialEnabledShouldOverrideRestore
			return "new DockWidgetPluginGuiInfo(" .. (formatValue(initialDockState) .. (", " .. (tostring(initialEnabled) .. (", " .. (tostring(initialEnabledShouldOverrideRestore) .. (", " .. (formatValue(floatingXSize) .. (", " .. (formatValue(floatingYSize) .. (", " .. (formatValue(minHeight) .. (", " .. (formatValue(minWidth) .. ")")))))))))))))
		end
		if _exp == "Enum" then
			_fallthrough = true
		end
		if _fallthrough or _exp == "EnumItem" then
			_fallthrough = true
		end
		if _fallthrough or _exp == "Enums" then
			return tostring(value)
		end
		if _exp == "Faces" then
			return "new Faces(" .. ((string.gsub(tostring(value), "(%u%l+)(,?)", "Enum.NormalId.%1%2")) .. ")")
		end
		if _exp == "Instance" then
			return value.Name
		end
		if _exp == "NumberRange" then
			local _binding = value
			local min = _binding.Min
			local max = _binding.Max
			return "new NumberRange(" .. (formatValue(min) .. (", " .. (formatValue(max) .. ")")))
		end
		if _exp == "NumberSequence" then
			local _exp_1 = value.Keypoints
			-- ▼ ReadonlyArray.map ▼
			local _newValue = table.create(#_exp_1)
			for _k, _v in _exp_1 do
				_newValue[_k] = formatValue(_v, _k - 1, _exp_1)
			end
			-- ▲ ReadonlyArray.map ▲
			return "new NumberSequence([" .. (table.concat(_newValue, ", ") .. "])")
		end
		if _exp == "NumberSequenceKeypoint" then
			local _binding = value
			local time = _binding.Time
			local num = _binding.Value
			local envelope = _binding.Envelope
			return "new NumberSequenceKeypoint(" .. (formatValue(time) .. (", " .. (formatValue(num) .. (", " .. (formatValue(envelope) .. ")")))))
		end
		if _exp == "PathWaypoint" then
			local _binding = value
			local pos = _binding.Position
			local action = _binding.Action
			return "new PathWaypoint(" .. (tostring(pos) .. (", " .. (tostring(action) .. ")")))
		end
		if _exp == "PhysicalProperties" then
			return "PHYSICAL_PROPERTIES"
		end
		if _exp == "Rect" then
			local _binding = value
			local _binding_1 = _binding.Min
			local minX = _binding_1.X
			local minY = _binding_1.Y
			local _binding_2 = _binding.Max
			local maxX = _binding_2.X
			local maxY = _binding_2.Y
			return "new Rect(" .. (formatValue(minX) .. (", " .. (formatValue(minY) .. (", " .. (formatValue(maxX) .. (", " .. (formatValue(maxY) .. ")")))))))
		end
		if _exp == "Region3" then
			local _binding = value
			local size = _binding.Size
			local cframe = _binding.CFrame
			return "new Region3(" .. (formatValue((cframe.Position - size) * 0.5) .. (", " .. (formatValue((cframe.Position + size) * 0.5) .. ")")))
		end
		if _exp == "UDim" then
			local _binding = value
			local offset = _binding.Offset
			local scale = _binding.Scale
			return "new UDim(" .. (formatValue(scale) .. (", " .. (formatValue(offset) .. ")")))
		end
		if _exp == "UDim2" then
			local _binding = value
			local _binding_1 = _binding.X
			local offsetX = _binding_1.Offset
			local scaleX = _binding_1.Scale
			local _binding_2 = _binding.Y
			local offsetY = _binding_2.Offset
			local scaleY = _binding_2.Scale
			return "new UDim2(" .. (formatValue(scaleX) .. (", " .. (formatValue(offsetX) .. (", " .. (formatValue(scaleY) .. (", " .. (formatValue(offsetY) .. ")")))))))
		end
		if _exp == "Vector2" then
			local _binding = value
			local x = _binding.X
			local y = _binding.Y
			return "new Vector2(" .. (formatValue(x) .. (", " .. (formatValue(y) .. ")")))
		end
		if _exp == "Vector3" then
			local _binding = value
			local x = _binding.X
			local y = _binding.Y
			local z = _binding.Z
			return "new Vector3(" .. (formatValue(x) .. (", " .. (formatValue(y) .. (", " .. (formatValue(z) .. ")")))))
		end
		if _exp == "string" then
			return if (string.find(value, "\n", 0, true)) == nil then '"' .. (tostring(value) .. '"') else "\`" .. (tostring(value) .. "\`")
		end
		if _exp == "number" then
			return tostring(round(value, POSITION_PRECISION))
		end
		return tostring(value)
	until true
end
return formatValue
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ModuleScript" referent="RBX67D2D271C50849508BBB8DEF00F3DD39">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">generateTree</string>
			<string name="ScriptGuid">{3CB1072C-744F-42FB-9E6D-0597B4D5B305}</string>
			<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local TS = require(script.Parent.include.RuntimeLib)
local formatValue = TS.import(script, script.Parent, "formatValue")
local getAPIDump = TS.import(script, script.Parent, "apiDump")
local IO_SERVE_URL = TS.import(script, script.Parent, "config").IO_SERVE_URL
local Feedback = TS.import(script, script.Parent, "feedback")
local Lighting = game:GetService("Lighting")
local HttpService = game:GetService("HttpService")
local propNames = {}
local function getPropNames(className)
	local _className = className
	local classPropNames = propNames[_className]
	if classPropNames == nil then
		local _exp = className
		local _result = getAPIDump()
		if _result ~= nil then
			local _className_1 = className
			_result = _result[_className_1]
			if _result ~= nil then
				local _members = _result.Members
				local _arg0 = function(m)
					return m.Name
				end
				-- ▼ ReadonlyArray.map ▼
				local _newValue = table.create(#_members)
				for _k, _v in _members do
					_newValue[_k] = _arg0(_v, _k - 1, _members)
				end
				-- ▲ ReadonlyArray.map ▲
				_result = _newValue
			end
		end
		local _condition = _result
		if _condition == nil then
			_condition = error("Unable to get indexable names for " .. className)
		end
		classPropNames = _condition
		local _classPropNames = classPropNames
		propNames[_exp] = _classPropNames
	end
	return classPropNames
end
-- * Given an object, will return an array of Children, excluding children with duplicate names
local function getUniqueChildren(object)
	local _set = {}
	for _, _v in getPropNames(object.ClassName) do
		_set[_v] = true
	end
	local takenNames = _set
	local shouldParse = {}
	for _, instance in object:GetChildren() do
		local _binding = instance
		local name = _binding.Name
		if takenNames[name] ~= nil then
			shouldParse[name] = nil
		else
			takenNames[name] = true
			shouldParse[name] = instance
		end
	end
	return shouldParse
end
local function getTSVariableName(name)
	local _condition = ((string.match(name, "^[%a_][%w_]*$")))
	if _condition == nil then
		_condition = "X"
	end
	return _condition
end
-- * Handwritten replacement function for properly extending roblox services
local function createTopLevelInterface(_param)
	local className = _param.ClassName
	local name = _param.Name
	repeat
		local _fallthrough = false
		if className == "Workspace" then
			return "interface Workspace extends Model"
		end
		if className == "Terrain" then
			return "interface Terrain extends BasePart"
		end
		if className == "StarterGui" then
			return "interface StarterGui extends BasePlayerGui"
		end
		if className == "StarterCharacterScripts" then
			return "interface StarterCharacterScripts extends StarterPlayerScripts"
		end
		if className == "ReplicatedFirst" then
			_fallthrough = true
		end
		if _fallthrough or className == "Lighting" then
			_fallthrough = true
		end
		if _fallthrough or className == "ReplicatedStorage" then
			_fallthrough = true
		end
		if _fallthrough or className == "ServerScriptService" then
			_fallthrough = true
		end
		if _fallthrough or className == "ServerStorage" then
			_fallthrough = true
		end
		if _fallthrough or className == "StarterPack" then
			_fallthrough = true
		end
		if _fallthrough or className == "StarterPlayer" then
			_fallthrough = true
		end
		if _fallthrough or className == "StarterPlayerScripts" then
			_fallthrough = true
		end
		if _fallthrough or className == "SoundService" then
			_fallthrough = true
		end
		if _fallthrough or className == "Chat" then
			_fallthrough = true
		end
		if _fallthrough or className == "TestService" then
			return "interface " .. (className .. " extends Instance")
		end
		return "type " .. (getTSVariableName(name) .. (" = " .. (className .. " &")))
	until true
end
local invalidTSBlacklist = {
	["do"] = true,
	["if"] = true,
	["in"] = true,
	["for"] = true,
	["let"] = true,
	["new"] = true,
	["try"] = true,
	["var"] = true,
	["case"] = true,
	["else"] = true,
	["enum"] = true,
	["eval"] = true,
	["false"] = true,
	["null"] = true,
	["this"] = true,
	["true"] = true,
	["void"] = true,
	["with"] = true,
	["break"] = true,
	["catch"] = true,
	["class"] = true,
	["const"] = true,
	["super"] = true,
	["throw"] = true,
	["while"] = true,
	["yield"] = true,
	["delete"] = true,
	["export"] = true,
	["import"] = true,
	["public"] = true,
	["return"] = true,
	["static"] = true,
	["switch"] = true,
	["typeof"] = true,
	["default"] = true,
	["extends"] = true,
	["finally"] = true,
	["package"] = true,
	["private"] = true,
	["continue"] = true,
	["debugger"] = true,
	["function"] = true,
	["arguments"] = true,
	["interface"] = true,
	["protected"] = true,
	["implements"] = true,
	["instanceof"] = true,
}
local function validTSIdentifier(str)
	local _str = str
	local _condition = not (invalidTSBlacklist[_str] ~= nil)
	if _condition then
		_condition = (string.find(str, "^[%a_$][%w_$]*$")) ~= nil
	end
	return if _condition then str else '["' .. (str .. '"]')
end
-- * Finds a valid name, given a desiredName. Continually checks desiredName${++num} until one does not exist in Lighting
local function getValidName(desiredName, parent)
	if parent == Lighting then
		local i = 1
		while parent:FindFirstChild(if i == 1 then desiredName else desiredName .. tostring(i)) do
			i += 1
		end
		return if i == 1 then desiredName else desiredName .. tostring(i)
	else
		local i = 2
		while parent:FindFirstChild(desiredName .. tostring(i)) do
			i += 1
		end
		return desiredName .. tostring(i)
	end
end
-- * Publishes a slice of a string, which should be maximum 19_999 characters
local function publishSlice(name, slice, parent)
	local theScript = Instance.new("Script")
	theScript.Source = slice
	theScript.Name = getValidName(name, parent)
	theScript.Parent = parent
	return theScript
end
-- * Writes output to Script objects inside of Lighting
local function writeToLighting(name, source)
	local _exp = string.split(name, "/")
	-- ▼ Array.pop ▼
	local _length = #_exp
	local _result = _exp[_length]
	_exp[_length] = nil
	-- ▲ Array.pop ▲
	name = _result
	local sourceSize = #source
	local topSlice = publishSlice(name, string.sub(source, 1, 20_000 - 1), Lighting)
	if sourceSize >= 20_000 then
		do
			local i = 20_000
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i += 20_000
				else
					_shouldIncrement = true
				end
				if not (i < #source) then
					break
				end
				local _exp_1 = name
				local _source = source
				local _i = i
				local _arg1 = i + 19_999
				publishSlice(_exp_1, string.sub(_source, _i, _arg1), topSlice)
			end
		end
		Feedback.new("Generated files in Lighting! Your file was too long to put in a single script, so check " .. (topSlice.Name .. "'s children."))
	else
		Feedback.new("Generated file \`" .. (topSlice.Name .. "\` in Lighting!"))
	end
end
-- * Writes output to io-serve
local function writeToIoServe(name, source)
	HttpService:RequestAsync({
		Url = IO_SERVE_URL .. ("/" .. name),
		Method = "PUT",
		Body = source,
	})
	-- new Feedback(`Wrote to file \`${name}\` in io-serve!`);
end
-- * Writes output to io-serve
local function patchToIoServe(name, source, start)
	if start == nil then
		start = 'import { EvaluateInstanceTree } from "@rbxts/validate-tree";\n\n'
	end
	local previousFile = HttpService:RequestAsync({
		Url = IO_SERVE_URL .. ("/" .. name),
		Method = "GET",
	})
	local _value = previousFile.Success and previousFile.Body
	if _value ~= "" and _value then
		source = "\n" .. source
	else
		source = start .. source
	end
	HttpService:RequestAsync({
		Url = IO_SERVE_URL .. ("/" .. name),
		Method = "PATCH",
		Body = source,
	})
	Feedback.new("Patched file \`" .. (name .. "\` in io-serve!"))
end
-- * Recursively generates trees for given objects
local function generateSubInterface(results, _param, depth)
	local instanceName = _param[1]
	local instance = _param[2]
	local _results = results
	local _arg0 = depth - 1
	local _arg0_1 = string.rep("\t", _arg0) .. (validTSIdentifier(instanceName) .. (": " .. instance.ClassName))
	table.insert(_results, _arg0_1)
	local children = getUniqueChildren(instance)
	if not (next(children) == nil) then
		table.insert(results, " & {\n")
		for _k, _v in children do
			local child = { _k, _v }
			generateSubInterface(results, child, depth + 1)
		end
		local _results_1 = results
		local _arg0_2 = depth - 1
		local _arg0_3 = string.rep("\t", _arg0_2)
		table.insert(_results_1, _arg0_3)
		table.insert(results, "}")
	end
	table.insert(results, ";\n")
end
-- * Generates an interface for a given instance.
local function generateInterface(instance, useIoServe)
	local results = { createTopLevelInterface(instance), " {\n" }
	for _k, _v in getUniqueChildren(instance) do
		local child = { _k, _v }
		generateSubInterface(results, child, 2)
	end
	table.insert(results, "}\n");
	(if useIoServe then writeToIoServe else writeToLighting)("types/" .. instance.Name .. ".d.ts", table.concat(results, ""))
	return true
end
local function generateSubRojoInterface(results, _param, depth)
	local instanceName = _param[1]
	local instance = _param[2]
	local children = getUniqueChildren(instance)
	local _results = results
	local _arg0 = depth - 1
	local _arg0_1 = string.rep("\t", _arg0)
	table.insert(_results, _arg0_1)
	local _results_1 = results
	local _arg0_2 = validTSIdentifier(instanceName)
	table.insert(_results_1, _arg0_2)
	table.insert(results, ": ")
	if not (next(children) == nil) then
		table.insert(results, "{\n")
		local _results_2 = results
		local _depth = depth
		local _arg0_3 = string.rep("\t", _depth)
		table.insert(_results_2, _arg0_3)
		table.insert(results, '$className: "')
		local _results_3 = results
		local _className = instance.ClassName
		table.insert(_results_3, _className)
		table.insert(results, '",\n')
		for _k, _v in children do
			local child = { _k, _v }
			generateSubRojoInterface(results, child, depth + 1)
		end
		local _results_4 = results
		local _arg0_4 = depth - 1
		local _arg0_5 = string.rep("\t", _arg0_4)
		table.insert(_results_4, _arg0_5)
		table.insert(results, "}")
	else
		table.insert(results, '"')
		local _results_2 = results
		local _className = instance.ClassName
		table.insert(_results_2, _className)
		table.insert(results, '"')
	end
	table.insert(results, ",\n")
end
-- * Generates a Rojo-esque definition for a given instance
local function generateRojoInterface(instance, useIoServe)
	local varName = getTSVariableName(instance.Name)
	local results = { "export const ", varName, ' = {\n\t$className: "', instance.ClassName, '",\n' }
	for _k, _v in getUniqueChildren(instance) do
		local child = { _k, _v }
		generateSubRojoInterface(results, child, 2)
	end
	table.insert(results, "} as const;\n\n")
	table.insert(results, "export type ")
	table.insert(results, varName)
	table.insert(results, " = EvaluateInstanceTree<typeof ")
	table.insert(results, varName)
	table.insert(results, ">;\n");
	(if useIoServe then patchToIoServe else writeToLighting)("src/tree-definitions.ts", table.concat(results, ""))
	return true
end
local defaultObjects = {}
local function getDefaultPropertyOfInstanceType(className, property)
	local defaultObj = defaultObjects[className]
	if not defaultObj then
		local attempt = { pcall(function()
			return Instance.new(className)
		end) }
		if attempt[1] then
			defaultObj = attempt[2]
			defaultObjects[className] = defaultObj
		else
			error(attempt[2])
		end
	end
	return defaultObj[property]
end
local hasText = function(obj)
	return obj:IsA("TextBox") or (obj:IsA("TextLabel") or obj:IsA("TextBox"))
end
local exclusionConditions = { {
	condition = function(obj)
		return obj:IsA("GuiObject")
	end,
	omitProperties = { "Transparency" },
}, {
	condition = function(obj)
		return obj:IsA("GuiObject") and obj.BackgroundTransparency == 1
	end,
	omitProperties = { "BackgroundColor3", "BorderColor3", "BorderSizePixel" },
}, {
	condition = function(obj)
		return obj:IsA("GuiObject") and obj.BorderSizePixel == 0
	end,
	omitProperties = { "BorderColor3" },
}, {
	condition = function(obj)
		return hasText(obj) and obj.TextStrokeTransparency == 1
	end,
	omitProperties = { "TextStrokeColor3" },
}, {
	condition = function(obj)
		return hasText(obj) and obj.TextTransparency == 1
	end,
	omitProperties = { "TextStrokeTransparency", "TextStrokeColor3", "TextColor3", "TextScaled", "Font", "FontSize", "Text", "TextTransparency", "TextWrapped", "TextXAlignment", "TextYAlignment" },
}, {
	condition = function(obj)
		return obj:IsA("BasePart")
	end,
	omitProperties = { "Position", "Rotation", "Orientation", "BrickColor" },
}, {
	condition = function(obj)
		return obj:IsA("Attachment") or obj:IsA("BasePart")
	end,
	omitProperties = { "Rotation", "CFrame" },
}, {
	condition = function(obj)
		return obj:IsA("MeshPart")
	end,
	omitProperties = { "MeshId" },
}, {
	condition = function(obj)
		return obj:IsA("LuaSourceContainer")
	end,
	omitProperties = { "Source" },
} }
local ignoredTags = {
	["Deprecated"] = true,
	["NotScriptable"] = true,
	["ReadOnly"] = true,
}
local validSecurityTags = {
	["None"] = true,
	["PluginSecurity"] = true,
}
local function isDisjointWith(a, b)
	for _, x in a do
		if b[x] ~= nil then
			return false
		end
	end
	return true
end
local function getPropertiesToCompile(rbxClass, instance, omittedProperties)
	if omittedProperties == nil then
		omittedProperties = {}
	end
	for _, _binding in exclusionConditions do
		local condition = _binding.condition
		local omitProperties = _binding.omitProperties
		if condition(instance) then
			for _1, omitProperty in omitProperties do
				omittedProperties[omitProperty] = true
			end
		end
	end
	local _members = rbxClass.Members
	local _arg0 = function(rbxMember)
		local _condition = rbxMember.MemberType == "Property"
		if _condition then
			local _omittedProperties = omittedProperties
			local _name = rbxMember.Name
			_condition = not (_omittedProperties[_name] ~= nil)
			if _condition then
				_condition = (not rbxMember.Tags or isDisjointWith(rbxMember.Tags, ignoredTags))
				if _condition then
					local _security = rbxMember.Security
					local _result
					if type(_security) == "string" then
						local _security_1 = rbxMember.Security
						_result = validSecurityTags[_security_1] ~= nil
					else
						local _read = rbxMember.Security.Read
						local _condition_1 = validSecurityTags[_read] ~= nil
						if _condition_1 then
							local _write = rbxMember.Security.Write
							_condition_1 = validSecurityTags[_write] ~= nil
						end
						_result = _condition_1
					end
					_condition = _result
					if _condition then
						_condition = instance[rbxMember.Name] ~= getDefaultPropertyOfInstanceType(instance.ClassName, rbxMember.Name)
					end
				end
			end
		end
		return _condition
	end
	-- ▼ ReadonlyArray.filter ▼
	local _newValue = {}
	local _length = 0
	for _k, _v in _members do
		if _arg0(_v, _k - 1, _members) == true then
			_length += 1
			_newValue[_length] = _v
		end
	end
	-- ▲ ReadonlyArray.filter ▲
	local _arg0_1 = function(_param, _param_1)
		local a = _param.Name
		local b = _param_1.Name
		return a ~= "Parent" and (b == "Parent" or a < b)
	end
	table.sort(_newValue, _arg0_1)
	return _newValue
end
local function instantiateHelper(apiDump, instance, results)
	local _apiDump = apiDump
	local _className = instance.ClassName
	local rbxClass = _apiDump[_className]
	if rbxClass then
		local varName = getTSVariableName(instance.Name)
		local _results = results
		local _arg0 = "const " .. (varName .. (' = new Instance("' .. (instance.ClassName .. '");\n')))
		table.insert(_results, _arg0)
		for _, _binding in getPropertiesToCompile(rbxClass, instance) do
			local prop = _binding.Name
			table.insert(results, varName)
			table.insert(results, ".")
			table.insert(results, prop)
			table.insert(results, " = ")
			local _results_1 = results
			local _arg0_1 = formatValue(instance[prop])
			table.insert(_results_1, _arg0_1)
			table.insert(results, ";\n")
		end
		table.insert(results, "\n")
		for _, child in instance:GetChildren() do
			instantiateHelper(apiDump, child, results)
		end
	end
	return results
end
-- * Generates TS Instantiation Code
local function generateInstantiation(instance, useIoServe)
	local apiDump = getAPIDump()
	if apiDump then
		(if useIoServe then patchToIoServe else writeToLighting)("src/" .. getTSVariableName(instance.Name) .. ".ts", table.concat(instantiateHelper(apiDump, instance, {}), ""))
		return true
	else
		return false
	end
end
local function roactHelper(apiDump, instance, results, depth)
	if depth == nil then
		depth = 0
	end
	local _apiDump = apiDump
	local _className = instance.ClassName
	local rbxClass = _apiDump[_className]
	if rbxClass then
		local _exp = instance:GetChildren()
		local _arg0 = function(child)
			return child:IsA("GuiObject") or (child:IsA("UIBase") or child:IsA("LayerCollector"))
		end
		-- ▼ ReadonlyArray.filter ▼
		local _newValue = {}
		local _length = 0
		for _k, _v in _exp do
			if _arg0(_v, _k - 1, _exp) == true then
				_length += 1
				_newValue[_length] = _v
			end
		end
		-- ▲ ReadonlyArray.filter ▲
		local children = _newValue
		local _depth = depth
		local indent = string.rep("\t", _depth)
		table.insert(results, indent)
		table.insert(results, "<")
		local _results = results
		local _arg0_1 = string.lower(instance.ClassName)
		table.insert(_results, _arg0_1)
		local propResults = {}
		local propLength = if #children > 0 then 1 else 2
		for _, _binding in getPropertiesToCompile(rbxClass, instance, {
			["Parent"] = true,
		}) do
			local prop = _binding.Name
			local valueStr = formatValue(instance[prop])
			if (string.find(valueStr, '^".+"$')) == nil then
				valueStr = "{" .. (valueStr .. "}")
			end
			propLength += (depth + 1) * 4 + #valueStr
			if prop == "Name" then
				local _arg0_2 = "Key=" .. valueStr
				table.insert(propResults, 1, _arg0_2)
				propLength += 3
			else
				local _arg0_2 = prop .. ("=" .. valueStr)
				table.insert(propResults, _arg0_2)
				propLength += #prop
			end
		end
		local multiline = propLength > 120
		if multiline then
			table.insert(results, "\n")
			local _results_1 = results
			local _arg0_2 = function(line)
				return indent .. "\t" .. line
			end
			-- ▼ ReadonlyArray.map ▼
			local _newValue_1 = table.create(#propResults)
			for _k, _v in propResults do
				_newValue_1[_k] = _arg0_2(_v, _k - 1, propResults)
			end
			-- ▲ ReadonlyArray.map ▲
			local _arg0_3 = table.concat(_newValue_1, "\n")
			table.insert(_results_1, _arg0_3)
		else
			table.insert(results, " ")
			local _results_1 = results
			local _arg0_2 = table.concat(propResults, " ")
			table.insert(_results_1, _arg0_2)
		end
		if #children > 0 then
			local _results_1 = results
			local _arg0_2 = if multiline then "\n" .. (indent .. ">") else ">"
			table.insert(_results_1, _arg0_2)
			for _, child in children do
				table.insert(results, "\n")
				roactHelper(apiDump, child, results, depth + 1)
			end
			table.insert(results, "\n")
			table.insert(results, indent)
			table.insert(results, "</")
			local _results_2 = results
			local _arg0_3 = string.lower(instance.ClassName)
			table.insert(_results_2, _arg0_3)
			table.insert(results, ">")
		else
			local _results_1 = results
			local _result
			if multiline then
				_result = "\n" .. indent .. "/>"
			else
				local _value = #propResults
				_result = if _value ~= 0 and (_value == _value and _value) then " />" else "/>"
			end
			table.insert(_results_1, _result)
		end
	end
	return results
end
-- * Generates TS Instantiation Code
local function generateRoactInstantiation(instance, useIoServe)
	local apiDump = getAPIDump()
	if apiDump then
		local fileName = "src/" .. getTSVariableName(instance.Name) .. ".tsx"
		local source = table.concat(roactHelper(apiDump, instance, {}), "")
		if useIoServe then
			patchToIoServe(fileName, source, 'import Roact from "@rbxts/roact";\n\n')
		else
			writeToLighting(fileName, source)
		end
		return true
	else
		return false
	end
end
return {
	["Instantiation code"] = generateInstantiation,
	["Roact TSX code"] = generateRoactInstantiation,
	["Rojo-esque tree"] = generateRojoInterface,
	["TS types"] = generateInterface,
}
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Script" referent="RBX083F23A13CD541D7A80DC2B48C4A1E97">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">Main</string>
			<token name="RunContext">0</token>
			<string name="ScriptGuid">{3FB1D7EA-E010-4E60-916B-EE51B8E27210}</string>
			<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local TS = require(script.include.RuntimeLib)
-- / <reference types="@rbxts/types/plugin"/>
-- TODO: Make it automatically add to `default.project.json` files
-- TODO: Make it customizable what name the single-file Rojoesque generator should go to
local _config = TS.import(script, script, "config")
local PLUGIN_NAME = _config.PLUGIN_NAME
local OPTIONS = _config.OPTIONS
local ICON_ID = _config.ICON_ID
local DEFAULT_SETTING = _config.DEFAULT_SETTING
local IO_SERVE_URL = _config.IO_SERVE_URL
local PLUGIN_DESCRIPTION = _config.PLUGIN_DESCRIPTION
local Radio = TS.import(script, script, "radio")
local generateOptions = TS.import(script, script, "generateTree")
local Feedback = TS.import(script, script, "feedback")
local delay = TS.import(script, script, "include", "node_modules", "@rbxts", "delay-spawn-wait").delay
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local Selection = game:GetService("Selection")
local isAutoActive = false
delay(1, function()
	local widgetSize = Vector2.new(227, 232)
	local DockWidget = plugin:CreateDockWidgetPluginGui(PLUGIN_NAME, DockWidgetPluginGuiInfo.new(Enum.InitialDockState.Right, false, false, widgetSize.X, widgetSize.Y, widgetSize.X, widgetSize.Y))
	DockWidget.Name = "rbxts-object-to-tree"
	DockWidget.Title = DockWidget.Name
	delay(0, function()
		DockWidget.Enabled = false
		return DockWidget.Enabled
	end)
	local Background = Instance.new("Frame")
	Background.AnchorPoint = Vector2.new(0.5, 0)
	Background.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Background.BorderColor3 = Color3.fromRGB(221, 221, 221)
	Background.Name = "Background"
	Background.Position = UDim2.new(0.5, 0, 0, 1)
	Background.Size = UDim2.new(1, 0, 1, 0)
	Background.ZIndex = -1
	local BackImage = Instance.new("ImageLabel")
	BackImage.AnchorPoint = Vector2.new(0.5, 0.5)
	BackImage.BackgroundTransparency = 1
	BackImage.Image = "rbxassetid://3561078226"
	BackImage.ImageTransparency = 0.88
	BackImage.Name = "BackImage"
	BackImage.Position = UDim2.new(0.5, 0, 0.5, 0)
	BackImage.Size = UDim2.new(0, 135, 0, 135)
	BackImage.ZIndex = 0
	BackImage.Parent = Background
	local Indicator = Instance.new("Frame")
	Indicator.BackgroundColor3 = Color3.fromRGB(4, 255, 0)
	Indicator.BorderSizePixel = 0
	Indicator.Name = "Indicator"
	Indicator.Position = UDim2.new(0, -1, 1, 2)
	Indicator.Size = UDim2.new(1, 2, 0, 4)
	Indicator.Visible = false
	local Choices = Instance.new("Frame")
	Choices.BackgroundTransparency = 1
	Choices.Name = "Choices"
	Choices.Position = UDim2.new(0, 0, 0, 0)
	Choices.Size = UDim2.new(1, 0, 1, 0)
	Choices.ZIndex = 10
	local Instructions = Instance.new("TextLabel")
	Instructions.BackgroundTransparency = 1
	Instructions.Font = Enum.Font.SourceSans
	Instructions.LayoutOrder = -1
	Instructions.Name = "Instructions"
	Instructions.Text = "  Export type:"
	Instructions.TextColor3 = Color3.fromRGB(0, 0, 0)
	Instructions.TextSize = 18
	Instructions.TextTransparency = 0.13
	Instructions.TextWrapped = true
	Instructions.TextXAlignment = Enum.TextXAlignment.Left
	Instructions.TextYAlignment = Enum.TextYAlignment.Center
	Instructions.Size = UDim2.new(-8, 1, 18, 0)
	Instructions.ZIndex = 2
	Instructions.Parent = Choices
	local BottomHint = Instance.new("TextLabel")
	BottomHint.TextSize = 11
	BottomHint.BackgroundTransparency = 1
	BottomHint.Font = Enum.Font.SourceSansSemibold
	BottomHint.LayoutOrder = 10
	BottomHint.Name = "BottomHint"
	BottomHint.Size = UDim2.new(-8, 1, 36, 0)
	BottomHint.Text = "Run `npx io-serve` with HTTP requests enabled to automatically place files in your project."
	BottomHint.TextColor3 = Color3.fromRGB(0, 0, 0)
	BottomHint.TextSize = 11
	BottomHint.TextTransparency = 0.46
	BottomHint.TextWrapped = true
	-- BottomHint.TextYAlignment = Enum.TextYAlignment.Bottom;
	BottomHint.ZIndex = 2
	BottomHint.Parent = Choices
	local UIGridLayout = Instance.new("UIGridLayout")
	UIGridLayout.CellPadding = UDim2.new(0, 0, 0, 0)
	UIGridLayout.CellSize = UDim2.new(1, 0, 0, 32)
	UIGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIGridLayout.FillDirection = Enum.FillDirection.Vertical
	UIGridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	local GeneratorFrame = Instance.new("Frame")
	GeneratorFrame.BackgroundTransparency = 1
	GeneratorFrame.Name = "GenerateButton"
	GeneratorFrame.Size = UDim2.new(0, 200, 0, 50)
	GeneratorFrame.Parent = Choices
	local ImageLabel = Instance.new("ImageLabel")
	ImageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
	ImageLabel.BackgroundTransparency = 1
	ImageLabel.Image = "rbxassetid://1934624205"
	ImageLabel.ImageColor3 = Color3.fromRGB(226, 36, 26)
	ImageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
	ImageLabel.ScaleType = Enum.ScaleType.Slice
	ImageLabel.Size = UDim2.new(0.5, 0, 1, -4)
	ImageLabel.SliceCenter = Rect.new(8, 8, 248, 248)
	ImageLabel.Parent = GeneratorFrame
	local GenerateButton = Instance.new("TextButton")
	GenerateButton.BackgroundTransparency = 1
	GenerateButton.Font = Enum.Font.SourceSansBold
	GenerateButton.Size = UDim2.new(1, 0, 1, 0)
	GenerateButton.Text = "GENERATE"
	GenerateButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	GenerateButton.TextSize = 20
	GenerateButton.Parent = GeneratorFrame
	local AutoButton = Instance.new("TextButton")
	AutoButton.BorderSizePixel = 0
	AutoButton.BackgroundTransparency = 0
	AutoButton.BackgroundColor3 = Color3.fromRGB(226, 36, 26)
	AutoButton.Font = Enum.Font.SourceSansBold
	AutoButton.Size = UDim2.new(.5, 0, 0, 20)
	AutoButton.AnchorPoint = Vector2.new(.5, 0)
	AutoButton.Position = UDim2.new(.5, 0, 0, 230)
	AutoButton.Text = "Auto Export"
	AutoButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	AutoButton.TextSize = 20
	AutoButton.Parent = Background
	local UICorner = Instance.new("UICorner")
	UICorner.Parent = AutoButton
	UICorner.CornerRadius = UDim.new(.1)
	local options = {}
	local function makeOption(option, order)
		local FullButton = Instance.new("TextButton")
		FullButton.BackgroundTransparency = 1
		FullButton.Font = Enum.Font.SourceSans
		FullButton.Name = option
		FullButton.Size = UDim2.new(0, 200, 0, 50)
		FullButton.Text = ""
		FullButton.TextColor3 = Color3.fromRGB(0, 0, 0)
		FullButton.TextSize = 14
		FullButton.LayoutOrder = order
		FullButton.Parent = Choices
		local GenerateType = Instance.new("TextLabel")
		GenerateType.BackgroundTransparency = 1
		GenerateType.Font = Enum.Font.SourceSans
		GenerateType.LayoutOrder = 1
		GenerateType.Name = option
		GenerateType.Position = UDim2.new(0, 48, 0, 0)
		GenerateType.Size = UDim2.new(1, -GenerateType.Position.X.Offset, 1, 0)
		GenerateType.Text = option
		GenerateType.TextColor3 = Color3.fromRGB(0, 0, 0)
		GenerateType.TextSize = 18
		GenerateType.TextTransparency = 0.13
		GenerateType.TextXAlignment = Enum.TextXAlignment.Left
		GenerateType.ZIndex = 11
		GenerateType.Parent = FullButton
		local checkbox = Radio.new({
			anchorPoint = Vector2.new(0, 0.5),
			position = UDim2.new(0, 16, 0.5, 0),
			size = 24,
			parent = FullButton,
			borderRadius = 16,
			isChecked = false,
			onChecked = function(isChecked)
				if isChecked then
					plugin:SetSetting(DEFAULT_SETTING, option)
					for opt, check in options do
						if opt ~= option and check:getChecked() then
							check:setChecked(false)
						end
					end
				end
			end,
		})
		FullButton.MouseButton1Click:Connect(function()
			if not checkbox:getChecked() then
				checkbox:setChecked(true)
			end
		end)
		local _option = option
		options[_option] = checkbox
	end
	for _k, _v in OPTIONS do
		makeOption(_v, _k - 1, OPTIONS)
	end
	options[DEFAULT_SETTING]:setChecked(true)
	GeneratorFrame.LayoutOrder = #OPTIONS
	local function getSelectedOption()
		for option, check in options do
			if check:getChecked() then
				return option
			end
		end
		return DEFAULT_SETTING
	end
	local function toggleSettings()
		DockWidget.Enabled = not DockWidget.Enabled
	end
	-- * tests to see if io-serve is available
	local function isIoServeAvailable()
		local result = { pcall(function()
			return HttpService:RequestAsync({
				Url = IO_SERVE_URL,
				Method = "HEAD",
			})
		end) }
		return result[1] and result[2].StatusCode == 200
	end
	local function getServices()
		local workspace = game:GetService("Workspace")
		local lighting = game:GetService("Lighting")
		local replicatedFirst = game:GetService("ReplicatedFirst")
		local replicatedStorage = game:GetService("ReplicatedStorage")
		local serverScriptService = game:GetService("ServerScriptService")
		local serverStorage = game:GetService("ServerStorage")
		local starterGui = game:GetService("StarterGui")
		local starterPack = game:GetService("StarterPack")
		return { workspace, lighting, replicatedFirst, replicatedStorage, serverScriptService, serverStorage, starterGui, starterPack }
	end
	local generating = false
	-- TODO: Function still runs while testing game, but IsEdit always returns true
	local function generate()
		if not generating then
			generating = true
			local selection = if isAutoActive then getServices() else Selection:Get()
			local selectionSize = #selection
			if 0 < selectionSize then
				local useIoServe = isIoServeAvailable()
				local success = true
				for _, selected in selection do
					local _exitType, _returns = TS.try(function()
						local _arg0 = getSelectedOption()
						if not generateOptions[_arg0](selected, useIoServe) then
							success = false
						end
					end, function(e)
						Feedback.new(tostring(e))
						return TS.TRY_BREAK
					end)
					if _exitType then
						break
					end
				end
				if success and (selectionSize ~= 1 and not isAutoActive) then
					Feedback.new(if useIoServe then "Sent multiple files to io-serve" else "Generated multiple files in Lighting!")
				end
			else
				if not isAutoActive then
					Feedback.new("Please select something to generate.")
				end
			end
			generating = false
		end
	end
	GenerateButton.MouseButton1Click:Connect(function()
		return generate()
	end)
	AutoButton.MouseButton1Click:Connect(function()
		isAutoActive = not isAutoActive
		AutoButton.BackgroundColor3 = if isAutoActive then Color3.fromRGB(43, 227, 26) else Color3.fromRGB(226, 36, 26)
	end)
	task.spawn(function()
		while true do
			if isAutoActive then
				generate()
			end
			task.wait(1)
		end
	end)
	Choices.Parent = Background
	UIGridLayout.Parent = Choices
	Indicator.Parent = Background
	Background.Parent = DockWidget
	plugin:CreateToolbar(PLUGIN_NAME):CreateButton(PLUGIN_NAME, PLUGIN_DESCRIPTION, "rbxassetid://" .. tostring(ICON_ID)).Click:Connect(toggleSettings)
end)
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBXCEF3BB65FEF34997AD73C6EBA1C31D36">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">apiDump</string>
				<string name="ScriptGuid">{D41A1121-ED7D-47A3-B80A-B9226CC15FEA}</string>
				<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local TS = require(script.Parent.include.RuntimeLib)
local Feedback = TS.import(script, script.Parent, "feedback")
local HttpService = game:GetService("HttpService")
local apiDump
return function()
	if apiDump then
		return apiDump
	else
		Feedback.new("Fetching API data...")
		-- alternative "https://anaminus.github.io/rbx/json/api/latest.json"
		local request = { pcall(function()
			return HttpService:GetAsync("https://raw.githubusercontent.com/CloneTrooper1019/Roblox-Client-Watch/roblox/API-Dump.json")
		end) }
		if request[1] then
			local apiRequest = { pcall(function()
				return HttpService:JSONDecode(request[2])
			end) }
			if apiRequest[1] then
				local dumpMap = {}
				for _, rbxClass in apiRequest[2].Classes do
					local _superclass = rbxClass.Superclass
					local superclass = dumpMap[_superclass]
					if superclass then
						for _1, rbxMember in superclass.Members do
							table.insert(rbxClass.Members, rbxMember)
						end
					end
					local _name = rbxClass.Name
					dumpMap[_name] = rbxClass
				end
				apiDump = dumpMap
				return apiDump
			else
				Feedback.new("[FATAL] Failed to decode API data.")
			end
		else
			Feedback.new("Failed to fetch API data. Please enable HttpService.HttpEnabled.")
		end
	end
end
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXE387E1EFFD9A470AAA269A0F00FD74FE">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">config</string>
				<string name="ScriptGuid">{2323DBF7-5FA3-4FE8-B82D-7E0670E44C3C}</string>
				<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local ICON_ID = 3561078226
local PLUGIN_NAME = "roblox-ts-object-to-tree"
local PLUGIN_DESCRIPTION = "A tool for converting instances to their TS tree form. Ignores all instances with name collisions."
local IO_SERVE_URL = "http://localhost:33333"
local OPTIONS = { "TS types", "Rojo-esque tree", "Instantiation code", "Roact TSX code" }
local DEFAULT_SETTING = OPTIONS[4]
return {
	ICON_ID = ICON_ID,
	PLUGIN_NAME = PLUGIN_NAME,
	PLUGIN_DESCRIPTION = PLUGIN_DESCRIPTION,
	IO_SERVE_URL = IO_SERVE_URL,
	OPTIONS = OPTIONS,
	DEFAULT_SETTING = DEFAULT_SETTING,
}
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX111AC22430DB4E59A85D836B893BC78D">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">feedback</string>
				<string name="ScriptGuid">{EC403B27-75D1-4783-BF65-8979FF532446}</string>
				<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local TextService = game:GetService("TextService")
local TEXT_SIZE = 18
local TEXT_FONT = Enum.Font.SourceSans
-- * A lightweight feedback system
local _class
do
	local Feedback = setmetatable({}, {
		__tostring = function()
			return "Feedback"
		end,
	})
	Feedback.__index = Feedback
	function Feedback.new(...)
		local self = setmetatable({}, Feedback)
		return self:constructor(...) or self
	end
	function Feedback:constructor(text)
		if Feedback.currentFeedback then
			Feedback.currentFeedback.feedbackScreen:Destroy()
		end
		local feedbackScreen = Instance.new("ScreenGui")
		feedbackScreen.Name = "FeedbackScreen"
		local feedbackText = Instance.new("TextLabel")
		feedbackText.AnchorPoint = Vector2.new(0.5, 0.5)
		feedbackText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		feedbackText.BorderSizePixel = 0
		feedbackText.Position = UDim2.new(0.5, 0, 0.5, 0)
		feedbackText.Font = TEXT_FONT
		feedbackText.Text = text
		feedbackText.TextSize = TEXT_SIZE
		feedbackText.Size = UDim2.new(0, TextService:GetTextSize(text, TEXT_SIZE, TEXT_FONT, Vector2.new(math.huge, math.huge)).X + 36, 0, 50)
		feedbackText.Parent = feedbackScreen
		feedbackScreen.Parent = game:GetService("CoreGui")
		self.feedbackScreen = feedbackScreen
		Feedback.currentFeedback = self
		delay(5, function()
			if Feedback.currentFeedback == self then
				feedbackScreen:Destroy()
				Feedback.currentFeedback = nil
			end
		end)
	end
	_class = Feedback
end
return _class
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX9B0E3CA5984848B1B26A430A7984DD59">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">formatValue</string>
				<string name="ScriptGuid">{6EA2C0FB-1E5B-4F9C-8FBB-1A3C105E0189}</string>
				<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local POSITION_PRECISION = 0.001
local ORIENTATION_PRECISION = 0.001
local function round(number, place)
	if place == nil then
		place = 1
	end
	return math.floor(number / place + 0.5) * place
end
--[[
	*
	* Returns a string representation of a number that can perfectly reproduce the number with a `tonumber` call
	* @param n the number you wish to have a string representation of
]]
local function getSignificantDigits(n)
	local str = tostring(n)
	if tonumber(str) == n then
		return str
	end
	do
		local i = 15
		local _shouldIncrement = false
		while true do
			if _shouldIncrement then
				i += 1
			else
				_shouldIncrement = true
			end
			if not (i <= 99) then
				break
			end
			local _exp = "%." .. (tostring(i) .. "g")
			local _n = n
			str = string.format(_exp, _n)
			if tonumber(str) == n then
				return str
			end
		end
	end
	return error("Couldn't reproduce accurate number for " .. tostring(n))
end
local function formatValue(value)
	local _value = value
	local _exp = typeof(_value)
	repeat
		local _fallthrough = false
		if _exp == "Axes" then
			return "new Axes(" .. ((string.gsub(tostring(value), "(%u)(,?)", "Enum.Axis.%1%2")) .. ")")
		end
		if _exp == "BrickColor" then
			return 'new BrickColor("' .. (value.Name .. '")')
		end
		if _exp == "CFrame" then
			-- this is admittedly a stupid algorithm.
			-- if you have a problem with it, submit a PR
			-- https://github.com/Validark/rbxts-Object-To-Tree
			local part = Instance.new("Part")
			part.CFrame = value
			local position = part.Position
			local orientation = part.Orientation
			part:Destroy()
			return "CFrame.fromOrientation(math.rad(" .. (tostring(round(orientation.X, ORIENTATION_PRECISION)) .. ("), math.rad(" .. (tostring(round(orientation.Y, ORIENTATION_PRECISION)) .. ("), math.rad(" .. (tostring(round(orientation.Z, ORIENTATION_PRECISION)) .. (")) + new Vector3(" .. (tostring(round(position.X, POSITION_PRECISION)) .. (", " .. (tostring(round(position.Y, POSITION_PRECISION)) .. (", " .. (tostring(round(position.Z, POSITION_PRECISION)) .. ")")))))))))))
		end
		if _exp == "Color3" then
			local _binding = value
			local R = _binding.R
			local G = _binding.G
			local B = _binding.B
			return "Color3.fromRGB(" .. (tostring(round(255 * R)) .. (", " .. (tostring(round(255 * G)) .. (", " .. (tostring(round(255 * B)) .. ")")))))
		end
		if _exp == "ColorSequence" then
			local _exp_1 = value.Keypoints
			-- ▼ ReadonlyArray.map ▼
			local _newValue = table.create(#_exp_1)
			for _k, _v in _exp_1 do
				_newValue[_k] = formatValue(_v, _k - 1, _exp_1)
			end
			-- ▲ ReadonlyArray.map ▲
			return "new ColorSequence([" .. (table.concat(_newValue, ", ") .. "])")
		end
		if _exp == "ColorSequenceKeypoint" then
			local _binding = value
			local time = _binding.Time
			local color = _binding.Value
			return "new ColorSequenceKeypoint(" .. (formatValue(time) .. (", " .. (formatValue(color) .. ")")))
		end
		if _exp == "DockWidgetPluginGuiInfo" then
			local _binding = value
			local floatingXSize = _binding.FloatingXSize
			local floatingYSize = _binding.FloatingYSize
			local minHeight = _binding.MinHeight
			local minWidth = _binding.MinWidth
			local initialDockState = _binding.InitialDockState
			local initialEnabled = _binding.InitialEnabled
			local initialEnabledShouldOverrideRestore = _binding.InitialEnabledShouldOverrideRestore
			return "new DockWidgetPluginGuiInfo(" .. (formatValue(initialDockState) .. (", " .. (tostring(initialEnabled) .. (", " .. (tostring(initialEnabledShouldOverrideRestore) .. (", " .. (formatValue(floatingXSize) .. (", " .. (formatValue(floatingYSize) .. (", " .. (formatValue(minHeight) .. (", " .. (formatValue(minWidth) .. ")")))))))))))))
		end
		if _exp == "Enum" then
			_fallthrough = true
		end
		if _fallthrough or _exp == "EnumItem" then
			_fallthrough = true
		end
		if _fallthrough or _exp == "Enums" then
			return tostring(value)
		end
		if _exp == "Faces" then
			return "new Faces(" .. ((string.gsub(tostring(value), "(%u%l+)(,?)", "Enum.NormalId.%1%2")) .. ")")
		end
		if _exp == "Instance" then
			return value.Name
		end
		if _exp == "NumberRange" then
			local _binding = value
			local min = _binding.Min
			local max = _binding.Max
			return "new NumberRange(" .. (formatValue(min) .. (", " .. (formatValue(max) .. ")")))
		end
		if _exp == "NumberSequence" then
			local _exp_1 = value.Keypoints
			-- ▼ ReadonlyArray.map ▼
			local _newValue = table.create(#_exp_1)
			for _k, _v in _exp_1 do
				_newValue[_k] = formatValue(_v, _k - 1, _exp_1)
			end
			-- ▲ ReadonlyArray.map ▲
			return "new NumberSequence([" .. (table.concat(_newValue, ", ") .. "])")
		end
		if _exp == "NumberSequenceKeypoint" then
			local _binding = value
			local time = _binding.Time
			local num = _binding.Value
			local envelope = _binding.Envelope
			return "new NumberSequenceKeypoint(" .. (formatValue(time) .. (", " .. (formatValue(num) .. (", " .. (formatValue(envelope) .. ")")))))
		end
		if _exp == "PathWaypoint" then
			local _binding = value
			local pos = _binding.Position
			local action = _binding.Action
			return "new PathWaypoint(" .. (tostring(pos) .. (", " .. (tostring(action) .. ")")))
		end
		if _exp == "PhysicalProperties" then
			return "PHYSICAL_PROPERTIES"
		end
		if _exp == "Rect" then
			local _binding = value
			local _binding_1 = _binding.Min
			local minX = _binding_1.X
			local minY = _binding_1.Y
			local _binding_2 = _binding.Max
			local maxX = _binding_2.X
			local maxY = _binding_2.Y
			return "new Rect(" .. (formatValue(minX) .. (", " .. (formatValue(minY) .. (", " .. (formatValue(maxX) .. (", " .. (formatValue(maxY) .. ")")))))))
		end
		if _exp == "Region3" then
			local _binding = value
			local size = _binding.Size
			local cframe = _binding.CFrame
			return "new Region3(" .. (formatValue((cframe.Position - size) * 0.5) .. (", " .. (formatValue((cframe.Position + size) * 0.5) .. ")")))
		end
		if _exp == "UDim" then
			local _binding = value
			local offset = _binding.Offset
			local scale = _binding.Scale
			return "new UDim(" .. (formatValue(scale) .. (", " .. (formatValue(offset) .. ")")))
		end
		if _exp == "UDim2" then
			local _binding = value
			local _binding_1 = _binding.X
			local offsetX = _binding_1.Offset
			local scaleX = _binding_1.Scale
			local _binding_2 = _binding.Y
			local offsetY = _binding_2.Offset
			local scaleY = _binding_2.Scale
			return "new UDim2(" .. (formatValue(scaleX) .. (", " .. (formatValue(offsetX) .. (", " .. (formatValue(scaleY) .. (", " .. (formatValue(offsetY) .. ")")))))))
		end
		if _exp == "Vector2" then
			local _binding = value
			local x = _binding.X
			local y = _binding.Y
			return "new Vector2(" .. (formatValue(x) .. (", " .. (formatValue(y) .. ")")))
		end
		if _exp == "Vector3" then
			local _binding = value
			local x = _binding.X
			local y = _binding.Y
			local z = _binding.Z
			return "new Vector3(" .. (formatValue(x) .. (", " .. (formatValue(y) .. (", " .. (formatValue(z) .. ")")))))
		end
		if _exp == "string" then
			return if (string.find(value, "\n", 0, true)) == nil then '"' .. (tostring(value) .. '"') else "\`" .. (tostring(value) .. "\`")
		end
		if _exp == "number" then
			return tostring(round(value, POSITION_PRECISION))
		end
		return tostring(value)
	until true
end
return formatValue
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX67D2D271C50849508BBB8DEF00F3DD39">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">generateTree</string>
				<string name="ScriptGuid">{3CB1072C-744F-42FB-9E6D-0597B4D5B305}</string>
				<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local TS = require(script.Parent.include.RuntimeLib)
local formatValue = TS.import(script, script.Parent, "formatValue")
local getAPIDump = TS.import(script, script.Parent, "apiDump")
local IO_SERVE_URL = TS.import(script, script.Parent, "config").IO_SERVE_URL
local Feedback = TS.import(script, script.Parent, "feedback")
local Lighting = game:GetService("Lighting")
local HttpService = game:GetService("HttpService")
local propNames = {}
local function getPropNames(className)
	local _className = className
	local classPropNames = propNames[_className]
	if classPropNames == nil then
		local _exp = className
		local _result = getAPIDump()
		if _result ~= nil then
			local _className_1 = className
			_result = _result[_className_1]
			if _result ~= nil then
				local _members = _result.Members
				local _arg0 = function(m)
					return m.Name
				end
				-- ▼ ReadonlyArray.map ▼
				local _newValue = table.create(#_members)
				for _k, _v in _members do
					_newValue[_k] = _arg0(_v, _k - 1, _members)
				end
				-- ▲ ReadonlyArray.map ▲
				_result = _newValue
			end
		end
		local _condition = _result
		if _condition == nil then
			_condition = error("Unable to get indexable names for " .. className)
		end
		classPropNames = _condition
		local _classPropNames = classPropNames
		propNames[_exp] = _classPropNames
	end
	return classPropNames
end
-- * Given an object, will return an array of Children, excluding children with duplicate names
local function getUniqueChildren(object)
	local _set = {}
	for _, _v in getPropNames(object.ClassName) do
		_set[_v] = true
	end
	local takenNames = _set
	local shouldParse = {}
	for _, instance in object:GetChildren() do
		local _binding = instance
		local name = _binding.Name
		if takenNames[name] ~= nil then
			shouldParse[name] = nil
		else
			takenNames[name] = true
			shouldParse[name] = instance
		end
	end
	return shouldParse
end
local function getTSVariableName(name)
	local _condition = ((string.match(name, "^[%a_][%w_]*$")))
	if _condition == nil then
		_condition = "X"
	end
	return _condition
end
-- * Handwritten replacement function for properly extending roblox services
local function createTopLevelInterface(_param)
	local className = _param.ClassName
	local name = _param.Name
	repeat
		local _fallthrough = false
		if className == "Workspace" then
			return "interface Workspace extends Model"
		end
		if className == "Terrain" then
			return "interface Terrain extends BasePart"
		end
		if className == "StarterGui" then
			return "interface StarterGui extends BasePlayerGui"
		end
		if className == "StarterCharacterScripts" then
			return "interface StarterCharacterScripts extends StarterPlayerScripts"
		end
		if className == "ReplicatedFirst" then
			_fallthrough = true
		end
		if _fallthrough or className == "Lighting" then
			_fallthrough = true
		end
		if _fallthrough or className == "ReplicatedStorage" then
			_fallthrough = true
		end
		if _fallthrough or className == "ServerScriptService" then
			_fallthrough = true
		end
		if _fallthrough or className == "ServerStorage" then
			_fallthrough = true
		end
		if _fallthrough or className == "StarterPack" then
			_fallthrough = true
		end
		if _fallthrough or className == "StarterPlayer" then
			_fallthrough = true
		end
		if _fallthrough or className == "StarterPlayerScripts" then
			_fallthrough = true
		end
		if _fallthrough or className == "SoundService" then
			_fallthrough = true
		end
		if _fallthrough or className == "Chat" then
			_fallthrough = true
		end
		if _fallthrough or className == "TestService" then
			return "interface " .. (className .. " extends Instance")
		end
		return "type " .. (getTSVariableName(name) .. (" = " .. (className .. " &")))
	until true
end
local invalidTSBlacklist = {
	["do"] = true,
	["if"] = true,
	["in"] = true,
	["for"] = true,
	["let"] = true,
	["new"] = true,
	["try"] = true,
	["var"] = true,
	["case"] = true,
	["else"] = true,
	["enum"] = true,
	["eval"] = true,
	["false"] = true,
	["null"] = true,
	["this"] = true,
	["true"] = true,
	["void"] = true,
	["with"] = true,
	["break"] = true,
	["catch"] = true,
	["class"] = true,
	["const"] = true,
	["super"] = true,
	["throw"] = true,
	["while"] = true,
	["yield"] = true,
	["delete"] = true,
	["export"] = true,
	["import"] = true,
	["public"] = true,
	["return"] = true,
	["static"] = true,
	["switch"] = true,
	["typeof"] = true,
	["default"] = true,
	["extends"] = true,
	["finally"] = true,
	["package"] = true,
	["private"] = true,
	["continue"] = true,
	["debugger"] = true,
	["function"] = true,
	["arguments"] = true,
	["interface"] = true,
	["protected"] = true,
	["implements"] = true,
	["instanceof"] = true,
}
local function validTSIdentifier(str)
	local _str = str
	local _condition = not (invalidTSBlacklist[_str] ~= nil)
	if _condition then
		_condition = (string.find(str, "^[%a_$][%w_$]*$")) ~= nil
	end
	return if _condition then str else '["' .. (str .. '"]')
end
-- * Finds a valid name, given a desiredName. Continually checks desiredName${++num} until one does not exist in Lighting
local function getValidName(desiredName, parent)
	if parent == Lighting then
		local i = 1
		while parent:FindFirstChild(if i == 1 then desiredName else desiredName .. tostring(i)) do
			i += 1
		end
		return if i == 1 then desiredName else desiredName .. tostring(i)
	else
		local i = 2
		while parent:FindFirstChild(desiredName .. tostring(i)) do
			i += 1
		end
		return desiredName .. tostring(i)
	end
end
-- * Publishes a slice of a string, which should be maximum 19_999 characters
local function publishSlice(name, slice, parent)
	local theScript = Instance.new("Script")
	theScript.Source = slice
	theScript.Name = getValidName(name, parent)
	theScript.Parent = parent
	return theScript
end
-- * Writes output to Script objects inside of Lighting
local function writeToLighting(name, source)
	local _exp = string.split(name, "/")
	-- ▼ Array.pop ▼
	local _length = #_exp
	local _result = _exp[_length]
	_exp[_length] = nil
	-- ▲ Array.pop ▲
	name = _result
	local sourceSize = #source
	local topSlice = publishSlice(name, string.sub(source, 1, 20_000 - 1), Lighting)
	if sourceSize >= 20_000 then
		do
			local i = 20_000
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i += 20_000
				else
					_shouldIncrement = true
				end
				if not (i < #source) then
					break
				end
				local _exp_1 = name
				local _source = source
				local _i = i
				local _arg1 = i + 19_999
				publishSlice(_exp_1, string.sub(_source, _i, _arg1), topSlice)
			end
		end
		Feedback.new("Generated files in Lighting! Your file was too long to put in a single script, so check " .. (topSlice.Name .. "'s children."))
	else
		Feedback.new("Generated file \`" .. (topSlice.Name .. "\` in Lighting!"))
	end
end
-- * Writes output to io-serve
local function writeToIoServe(name, source)
	HttpService:RequestAsync({
		Url = IO_SERVE_URL .. ("/" .. name),
		Method = "PUT",
		Body = source,
	})
	-- new Feedback(`Wrote to file \`${name}\` in io-serve!`);
end
-- * Writes output to io-serve
local function patchToIoServe(name, source, start)
	if start == nil then
		start = 'import { EvaluateInstanceTree } from "@rbxts/validate-tree";\n\n'
	end
	local previousFile = HttpService:RequestAsync({
		Url = IO_SERVE_URL .. ("/" .. name),
		Method = "GET",
	})
	local _value = previousFile.Success and previousFile.Body
	if _value ~= "" and _value then
		source = "\n" .. source
	else
		source = start .. source
	end
	HttpService:RequestAsync({
		Url = IO_SERVE_URL .. ("/" .. name),
		Method = "PATCH",
		Body = source,
	})
	Feedback.new("Patched file \`" .. (name .. "\` in io-serve!"))
end
-- * Recursively generates trees for given objects
local function generateSubInterface(results, _param, depth)
	local instanceName = _param[1]
	local instance = _param[2]
	local _results = results
	local _arg0 = depth - 1
	local _arg0_1 = string.rep("\t", _arg0) .. (validTSIdentifier(instanceName) .. (": " .. instance.ClassName))
	table.insert(_results, _arg0_1)
	local children = getUniqueChildren(instance)
	if not (next(children) == nil) then
		table.insert(results, " & {\n")
		for _k, _v in children do
			local child = { _k, _v }
			generateSubInterface(results, child, depth + 1)
		end
		local _results_1 = results
		local _arg0_2 = depth - 1
		local _arg0_3 = string.rep("\t", _arg0_2)
		table.insert(_results_1, _arg0_3)
		table.insert(results, "}")
	end
	table.insert(results, ";\n")
end
-- * Generates an interface for a given instance.
local function generateInterface(instance, useIoServe)
	local results = { createTopLevelInterface(instance), " {\n" }
	for _k, _v in getUniqueChildren(instance) do
		local child = { _k, _v }
		generateSubInterface(results, child, 2)
	end
	table.insert(results, "}\n");
	(if useIoServe then writeToIoServe else writeToLighting)("types/" .. instance.Name .. ".d.ts", table.concat(results, ""))
	return true
end
local function generateSubRojoInterface(results, _param, depth)
	local instanceName = _param[1]
	local instance = _param[2]
	local children = getUniqueChildren(instance)
	local _results = results
	local _arg0 = depth - 1
	local _arg0_1 = string.rep("\t", _arg0)
	table.insert(_results, _arg0_1)
	local _results_1 = results
	local _arg0_2 = validTSIdentifier(instanceName)
	table.insert(_results_1, _arg0_2)
	table.insert(results, ": ")
	if not (next(children) == nil) then
		table.insert(results, "{\n")
		local _results_2 = results
		local _depth = depth
		local _arg0_3 = string.rep("\t", _depth)
		table.insert(_results_2, _arg0_3)
		table.insert(results, '$className: "')
		local _results_3 = results
		local _className = instance.ClassName
		table.insert(_results_3, _className)
		table.insert(results, '",\n')
		for _k, _v in children do
			local child = { _k, _v }
			generateSubRojoInterface(results, child, depth + 1)
		end
		local _results_4 = results
		local _arg0_4 = depth - 1
		local _arg0_5 = string.rep("\t", _arg0_4)
		table.insert(_results_4, _arg0_5)
		table.insert(results, "}")
	else
		table.insert(results, '"')
		local _results_2 = results
		local _className = instance.ClassName
		table.insert(_results_2, _className)
		table.insert(results, '"')
	end
	table.insert(results, ",\n")
end
-- * Generates a Rojo-esque definition for a given instance
local function generateRojoInterface(instance, useIoServe)
	local varName = getTSVariableName(instance.Name)
	local results = { "export const ", varName, ' = {\n\t$className: "', instance.ClassName, '",\n' }
	for _k, _v in getUniqueChildren(instance) do
		local child = { _k, _v }
		generateSubRojoInterface(results, child, 2)
	end
	table.insert(results, "} as const;\n\n")
	table.insert(results, "export type ")
	table.insert(results, varName)
	table.insert(results, " = EvaluateInstanceTree<typeof ")
	table.insert(results, varName)
	table.insert(results, ">;\n");
	(if useIoServe then patchToIoServe else writeToLighting)("src/tree-definitions.ts", table.concat(results, ""))
	return true
end
local defaultObjects = {}
local function getDefaultPropertyOfInstanceType(className, property)
	local defaultObj = defaultObjects[className]
	if not defaultObj then
		local attempt = { pcall(function()
			return Instance.new(className)
		end) }
		if attempt[1] then
			defaultObj = attempt[2]
			defaultObjects[className] = defaultObj
		else
			error(attempt[2])
		end
	end
	return defaultObj[property]
end
local hasText = function(obj)
	return obj:IsA("TextBox") or (obj:IsA("TextLabel") or obj:IsA("TextBox"))
end
local exclusionConditions = { {
	condition = function(obj)
		return obj:IsA("GuiObject")
	end,
	omitProperties = { "Transparency" },
}, {
	condition = function(obj)
		return obj:IsA("GuiObject") and obj.BackgroundTransparency == 1
	end,
	omitProperties = { "BackgroundColor3", "BorderColor3", "BorderSizePixel" },
}, {
	condition = function(obj)
		return obj:IsA("GuiObject") and obj.BorderSizePixel == 0
	end,
	omitProperties = { "BorderColor3" },
}, {
	condition = function(obj)
		return hasText(obj) and obj.TextStrokeTransparency == 1
	end,
	omitProperties = { "TextStrokeColor3" },
}, {
	condition = function(obj)
		return hasText(obj) and obj.TextTransparency == 1
	end,
	omitProperties = { "TextStrokeTransparency", "TextStrokeColor3", "TextColor3", "TextScaled", "Font", "FontSize", "Text", "TextTransparency", "TextWrapped", "TextXAlignment", "TextYAlignment" },
}, {
	condition = function(obj)
		return obj:IsA("BasePart")
	end,
	omitProperties = { "Position", "Rotation", "Orientation", "BrickColor" },
}, {
	condition = function(obj)
		return obj:IsA("Attachment") or obj:IsA("BasePart")
	end,
	omitProperties = { "Rotation", "CFrame" },
}, {
	condition = function(obj)
		return obj:IsA("MeshPart")
	end,
	omitProperties = { "MeshId" },
}, {
	condition = function(obj)
		return obj:IsA("LuaSourceContainer")
	end,
	omitProperties = { "Source" },
} }
local ignoredTags = {
	["Deprecated"] = true,
	["NotScriptable"] = true,
	["ReadOnly"] = true,
}
local validSecurityTags = {
	["None"] = true,
	["PluginSecurity"] = true,
}
local function isDisjointWith(a, b)
	for _, x in a do
		if b[x] ~= nil then
			return false
		end
	end
	return true
end
local function getPropertiesToCompile(rbxClass, instance, omittedProperties)
	if omittedProperties == nil then
		omittedProperties = {}
	end
	for _, _binding in exclusionConditions do
		local condition = _binding.condition
		local omitProperties = _binding.omitProperties
		if condition(instance) then
			for _1, omitProperty in omitProperties do
				omittedProperties[omitProperty] = true
			end
		end
	end
	local _members = rbxClass.Members
	local _arg0 = function(rbxMember)
		local _condition = rbxMember.MemberType == "Property"
		if _condition then
			local _omittedProperties = omittedProperties
			local _name = rbxMember.Name
			_condition = not (_omittedProperties[_name] ~= nil)
			if _condition then
				_condition = (not rbxMember.Tags or isDisjointWith(rbxMember.Tags, ignoredTags))
				if _condition then
					local _security = rbxMember.Security
					local _result
					if type(_security) == "string" then
						local _security_1 = rbxMember.Security
						_result = validSecurityTags[_security_1] ~= nil
					else
						local _read = rbxMember.Security.Read
						local _condition_1 = validSecurityTags[_read] ~= nil
						if _condition_1 then
							local _write = rbxMember.Security.Write
							_condition_1 = validSecurityTags[_write] ~= nil
						end
						_result = _condition_1
					end
					_condition = _result
					if _condition then
						_condition = instance[rbxMember.Name] ~= getDefaultPropertyOfInstanceType(instance.ClassName, rbxMember.Name)
					end
				end
			end
		end
		return _condition
	end
	-- ▼ ReadonlyArray.filter ▼
	local _newValue = {}
	local _length = 0
	for _k, _v in _members do
		if _arg0(_v, _k - 1, _members) == true then
			_length += 1
			_newValue[_length] = _v
		end
	end
	-- ▲ ReadonlyArray.filter ▲
	local _arg0_1 = function(_param, _param_1)
		local a = _param.Name
		local b = _param_1.Name
		return a ~= "Parent" and (b == "Parent" or a < b)
	end
	table.sort(_newValue, _arg0_1)
	return _newValue
end
local function instantiateHelper(apiDump, instance, results)
	local _apiDump = apiDump
	local _className = instance.ClassName
	local rbxClass = _apiDump[_className]
	if rbxClass then
		local varName = getTSVariableName(instance.Name)
		local _results = results
		local _arg0 = "const " .. (varName .. (' = new Instance("' .. (instance.ClassName .. '");\n')))
		table.insert(_results, _arg0)
		for _, _binding in getPropertiesToCompile(rbxClass, instance) do
			local prop = _binding.Name
			table.insert(results, varName)
			table.insert(results, ".")
			table.insert(results, prop)
			table.insert(results, " = ")
			local _results_1 = results
			local _arg0_1 = formatValue(instance[prop])
			table.insert(_results_1, _arg0_1)
			table.insert(results, ";\n")
		end
		table.insert(results, "\n")
		for _, child in instance:GetChildren() do
			instantiateHelper(apiDump, child, results)
		end
	end
	return results
end
-- * Generates TS Instantiation Code
local function generateInstantiation(instance, useIoServe)
	local apiDump = getAPIDump()
	if apiDump then
		(if useIoServe then patchToIoServe else writeToLighting)("src/" .. getTSVariableName(instance.Name) .. ".ts", table.concat(instantiateHelper(apiDump, instance, {}), ""))
		return true
	else
		return false
	end
end
local function roactHelper(apiDump, instance, results, depth)
	if depth == nil then
		depth = 0
	end
	local _apiDump = apiDump
	local _className = instance.ClassName
	local rbxClass = _apiDump[_className]
	if rbxClass then
		local _exp = instance:GetChildren()
		local _arg0 = function(child)
			return child:IsA("GuiObject") or (child:IsA("UIBase") or child:IsA("LayerCollector"))
		end
		-- ▼ ReadonlyArray.filter ▼
		local _newValue = {}
		local _length = 0
		for _k, _v in _exp do
			if _arg0(_v, _k - 1, _exp) == true then
				_length += 1
				_newValue[_length] = _v
			end
		end
		-- ▲ ReadonlyArray.filter ▲
		local children = _newValue
		local _depth = depth
		local indent = string.rep("\t", _depth)
		table.insert(results, indent)
		table.insert(results, "<")
		local _results = results
		local _arg0_1 = string.lower(instance.ClassName)
		table.insert(_results, _arg0_1)
		local propResults = {}
		local propLength = if #children > 0 then 1 else 2
		for _, _binding in getPropertiesToCompile(rbxClass, instance, {
			["Parent"] = true,
		}) do
			local prop = _binding.Name
			local valueStr = formatValue(instance[prop])
			if (string.find(valueStr, '^".+"$')) == nil then
				valueStr = "{" .. (valueStr .. "}")
			end
			propLength += (depth + 1) * 4 + #valueStr
			if prop == "Name" then
				local _arg0_2 = "Key=" .. valueStr
				table.insert(propResults, 1, _arg0_2)
				propLength += 3
			else
				local _arg0_2 = prop .. ("=" .. valueStr)
				table.insert(propResults, _arg0_2)
				propLength += #prop
			end
		end
		local multiline = propLength > 120
		if multiline then
			table.insert(results, "\n")
			local _results_1 = results
			local _arg0_2 = function(line)
				return indent .. "\t" .. line
			end
			-- ▼ ReadonlyArray.map ▼
			local _newValue_1 = table.create(#propResults)
			for _k, _v in propResults do
				_newValue_1[_k] = _arg0_2(_v, _k - 1, propResults)
			end
			-- ▲ ReadonlyArray.map ▲
			local _arg0_3 = table.concat(_newValue_1, "\n")
			table.insert(_results_1, _arg0_3)
		else
			table.insert(results, " ")
			local _results_1 = results
			local _arg0_2 = table.concat(propResults, " ")
			table.insert(_results_1, _arg0_2)
		end
		if #children > 0 then
			local _results_1 = results
			local _arg0_2 = if multiline then "\n" .. (indent .. ">") else ">"
			table.insert(_results_1, _arg0_2)
			for _, child in children do
				table.insert(results, "\n")
				roactHelper(apiDump, child, results, depth + 1)
			end
			table.insert(results, "\n")
			table.insert(results, indent)
			table.insert(results, "</")
			local _results_2 = results
			local _arg0_3 = string.lower(instance.ClassName)
			table.insert(_results_2, _arg0_3)
			table.insert(results, ">")
		else
			local _results_1 = results
			local _result
			if multiline then
				_result = "\n" .. indent .. "/>"
			else
				local _value = #propResults
				_result = if _value ~= 0 and (_value == _value and _value) then " />" else "/>"
			end
			table.insert(_results_1, _result)
		end
	end
	return results
end
-- * Generates TS Instantiation Code
local function generateRoactInstantiation(instance, useIoServe)
	local apiDump = getAPIDump()
	if apiDump then
		local fileName = "src/" .. getTSVariableName(instance.Name) .. ".tsx"
		local source = table.concat(roactHelper(apiDump, instance, {}), "")
		if useIoServe then
			patchToIoServe(fileName, source, 'import Roact from "@rbxts/roact";\n\n')
		else
			writeToLighting(fileName, source)
		end
		return true
	else
		return false
	end
end
return {
	["Instantiation code"] = generateInstantiation,
	["Roact TSX code"] = generateRoactInstantiation,
	["Rojo-esque tree"] = generateRojoInterface,
	["TS types"] = generateInterface,
}
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX4915D5D2084A4957A3E8F05F97AD100C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">radio</string>
				<string name="ScriptGuid">{B8BD3249-4623-499F-8FA1-9B93890CA4F3}</string>
				<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local TS = require(script.Parent.include.RuntimeLib)
-- THE FOLLOWING LIBRARY IS INCLUDED BECAUSE THIS HAS NOT BEEN FINALIZED ENOUGH TO BE A LIBRARY
-- However, it should be good enough for this particular case.
-- @author Validark
local Cue = TS.import(script, script.Parent, "include", "node_modules", "@rbxts", "cue")
local Linear = TS.import(script, script.Parent, "include", "node_modules", "@rbxts", "easing-functions").Linear
local Tween = TS.import(script, script.Parent, "include", "node_modules", "@rbxts", "tween").default
--[[
	*
	* Returns a table wherein an object's writable properties can be specified,
	* while also allowing functions to be passed in which can be bound to a Cue.
]]
local frames = {}
local FRAMES_PER_ANIMATION = 30
local ANIMATION_TIME = 0.25
local COLUMNS = 15
local DIMENSION_X = 36
local DIMENSION_Y = 36
local HOVER_FRAMES = 6
local HOVER_ANIMATION_TIME = 0.1
local OLD_IMAGES = {
	[0] = 3336269098,
	[2] = 3336269399,
	[4] = 3336269669,
	[8] = 3336269958,
}
local IMAGES = {
	[0] = 3336269098,
	[2] = 3336484156,
	[4] = 3336484351,
	[8] = 3336484559,
	[16] = 3336484747,
}
do
	local i = 0
	local _shouldIncrement = false
	while true do
		if _shouldIncrement then
			i += 1
		else
			_shouldIncrement = true
		end
		if not (i < 60) then
			break
		end
		frames[i + 1] = Vector2.new((i % COLUMNS) * DIMENSION_X, math.floor(i / COLUMNS) * DIMENSION_Y)
	end
end
local numCheckboxes = 0
local Canceler = {
	Running = false,
}
-- * A material design Checkbox element.
local Radio
do
	Radio = setmetatable({}, {
		__tostring = function()
			return "Radio"
		end,
	})
	Radio.__index = Radio
	function Radio.new(...)
		local self = setmetatable({}, Radio)
		return self:constructor(...) or self
	end
	function Radio:constructor(settings)
		self.currentTween = Canceler
		self.isHovering = false
		self.hoverFrame = 0
		self.isDisabled = false
		self.onChecked = Cue.new()
		local _binding = self
		local onChecked = _binding.onChecked
		local button = Instance.new("ImageButton")
		button.BackgroundTransparency = 1
		local _original = numCheckboxes
		numCheckboxes += 1
		button.Name = "Checkbox" .. tostring(_original)
		local check = Instance.new("ImageLabel")
		check.AnchorPoint = Vector2.new(0.5, 0.5)
		check.BackgroundTransparency = 1
		check.ImageRectSize = Vector2.new(36, 36)
		check.Position = UDim2.new(0.5, 0, 0.5, 0)
		check.Size = UDim2.new(0.75, 0, 0.75, 0)
		check.Parent = button
		self.button = button
		self.check = check
		local switchChecked = function()
			if not self:getChecked() then
				self:setChecked(not self.isChecked)
			end
		end
		local enterHoverState = function()
			self.isHovering = true
			if self.isChecked == false then
				if self.currentTween.Running then
					self.currentTween:Cancel()
				end
				self.currentTween = Tween(HOVER_ANIMATION_TIME, Linear, function(x)
					local _exp = self.check
					local _exp_1 = frames
					self.hoverFrame = math.floor(x + 0.5)
					_exp.ImageRectOffset = _exp_1[(self.hoverFrame) + 1]
					return _exp.ImageRectOffset
				end, self.hoverFrame % 7, HOVER_FRAMES)
			end
		end
		local exitHoverState = function()
			self.isHovering = false
			if self.isChecked == false then
				if self.currentTween.Running then
					self.currentTween:Cancel()
				end
				self.currentTween = Tween(HOVER_ANIMATION_TIME, Linear, function(x)
					local _exp = frames
					self.hoverFrame = math.floor(x + 0.5)
					check.ImageRectOffset = _exp[(self.hoverFrame) + 1]
					return check.ImageRectOffset
				end, self.hoverFrame % 7, 0)
			end
		end
		button.MouseEnter:Connect(enterHoverState)
		button.MouseLeave:Connect(exitHoverState)
		button.MouseButton1Click:Connect(switchChecked)
		if settings then
			local _binding_1 = settings
			local position = _binding_1.position
			local anchorPoint = _binding_1.anchorPoint
			self.isChecked = settings.isChecked
			self:setSize(settings.size or 24)
			self:setBorderRadius(if settings.borderRadius == nil then 2 else settings.borderRadius)
			self:setTheme(settings.theme or "Light")
			if position then
				button.Position = position
			end
			if anchorPoint then
				button.AnchorPoint = anchorPoint
			end
			button.Parent = settings.parent
			onChecked:bind(settings.onChecked)
			onChecked:go(settings.isChecked)
		else
			self.isChecked = false
			self:setSize(24)
			self:setBorderRadius(2)
			self:setTheme("Light")
		end
		delay(0.5, function()
			return self:setChecked(self.isChecked)
		end)
	end
	function Radio:getTheme()
		return if self.isLightTheme then "Light" else "Dark"
	end
	function Radio:setTheme(theme)
		self.isLightTheme = theme == "Light"
		local isLightTheme = (self.isLightTheme)
		if self.isChecked == false then
			local _binding = self
			local check = _binding.check
			check.ImageColor3 = if isLightTheme then Color3.fromRGB(0, 0, 0) else Color3.fromRGB(255, 255, 255)
			check.ImageTransparency = if isLightTheme then (if self.isDisabled then 0.74 else 0.46) elseif self.isDisabled then 0.7 else 0.3
		end
	end
	function Radio:getPosition()
		return self.button.Position
	end
	function Radio:setPosition(position)
		self.button.Position = position
	end
	function Radio:getSize()
		return self.button.Size.X.Offset
	end
	function Radio:setSize(size)
		self.button.Size = UDim2.new(0, size, 0, size)
	end
	function Radio:getBorderRadius()
		local assetId = tonumber(string.sub(self.check.Image, 13))
		for borderRadius, id in pairs(IMAGES) do
			if assetId == id then
				return borderRadius
			end
		end
		return 0
	end
	function Radio:setBorderRadius(borderRadius)
		self.check.Image = "rbxassetid://" .. tostring(IMAGES[borderRadius])
	end
	function Radio:getParent()
		return self.button.Parent
	end
	function Radio:setParent(parent)
		self.button.Parent = parent
	end
	function Radio:getAnchorPoint()
		return self.button.AnchorPoint
	end
	function Radio:setAnchorPoint(anchorPoint)
		self.button.AnchorPoint = anchorPoint
	end
	function Radio:destroy()
		self.onChecked:unbindAll()
		self.button:Destroy()
		self.check:Destroy()
	end
	function Radio:setChecked(isChecked)
		self.isChecked = isChecked
		self.onChecked:go(isChecked)
		local _binding = self
		local check = _binding.check
		if isChecked then
			check.ImageTransparency = 0
			check.ImageColor3 = Color3.fromRGB(0, 150, 136)
			if self.currentTween.Running then
				self.currentTween:Cancel()
			end
			self.currentTween = Tween(ANIMATION_TIME, Linear, function(x)
				local _exp = frames
				self.hoverFrame = math.floor(x + 0.5)
				check.ImageRectOffset = _exp[(self.hoverFrame) + 1]
				return check.ImageRectOffset
			end, if self.hoverFrame < 7 then self.hoverFrame else 0, FRAMES_PER_ANIMATION)
		else
			check.ImageTransparency = 0.46
			check.ImageColor3 = Color3.fromRGB(0, 0, 0)
			if self.currentTween.Running then
				self.currentTween:Cancel()
			end
			local currentTween = Tween(ANIMATION_TIME, Linear, function(x)
				local _exp = frames
				self.hoverFrame = math.floor(x + 0.5) % 60
				check.ImageRectOffset = _exp[(self.hoverFrame) + 1]
				return check.ImageRectOffset
			end, self.hoverFrame, 60 - (if self.isHovering then 0 else 0))
			-- currentTween.FinishCallback = finished => {
			-- if (finished) check.ImageRectOffset = frames[(this.hoverFrame = 6)];
			-- };
			self.currentTween = currentTween
		end
	end
	function Radio:getChecked()
		return self.isChecked
	end
	function Radio:clone()
		return Radio.new({
			isChecked = self.isChecked,
			position = self.button.Position,
			anchorPoint = self.button.AnchorPoint,
			size = self.button.Size.X.Offset,
			borderRadius = self:getBorderRadius(),
		})
	end
end
return Radio
]]></ProtectedString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX0769754DC07C4194A452FF3B3A505657">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">include</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX27E934BA2761464DA56CFC6CAA0D607C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Promise</string>
					<string name="ScriptGuid">{0E67793B-D12C-4D28-BAD4-A2C65C0B6A02}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Return a Promise from the success or failure handler and it will be chained onto.

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::


	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(traceback, finallyHandler, resolve, reject)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, *or* cancelled.

	Returns a new promise chained from this promise.

	:::caution
	If the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `finally` or `done` will run in the case of cancellation.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Set a handler that will be called only if the Promise resolves or is cancelled. This method is similar to `finally`, except it doesn't catch rejections.

	:::caution
	`done` should be reserved specifically when you want to perform some operation after the Promise is finished (like `finally`), but you don't want to consume rejections (like in <a href="/roblox-lua-promise/lib/Examples.html#cancellable-animation-sequence">this example</a>). You should use `andThen` instead if you only care about the Resolved case.
	:::

	:::warning
	Like `finally`, if the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `done` and `finally` will run in the case of cancellation.
	:::

	Returns a new promise chained from this promise.

	@param doneHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:done(doneHandler)
	assert(doneHandler == nil or isCallable(doneHandler), string.format(ERROR_NON_FUNCTION, "Promise:done"))
	return self:_finally(debug.traceback(nil, 2), doneHandler, true)
end

--[=[
	Same as `andThenCall`, except for `done`.

	Attaches a `done` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:doneCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[=[
	Attaches a `done` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:doneReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:done(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXBB26EDB0B404495BB15D2CD10120E590">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RuntimeLib</string>
					<string name="ScriptGuid">{8F35BC89-4B6C-47EC-97B9-C69E83ADDC23}</string>
					<ProtectedString name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")

local OUTPUT_PREFIX = "roblox-ts: "
local NODE_MODULES = "node_modules"
local DEFAULT_SCOPE = "@rbxts"

local TS = {}

TS.Promise = Promise

local function isPlugin(context)
	return RunService:IsStudio() and context:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

function TS.getModule(context, scope, moduleName)
	-- legacy call signature
	if moduleName == nil then
		moduleName = scope
		scope = DEFAULT_SCOPE
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local object = context
	repeat
		local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)
		if nodeModulesFolder then
			local scopeFolder = nodeModulesFolder:FindFirstChild(scope)
			if scopeFolder then
				local module = scopeFolder:FindFirstChild(moduleName)
				if module then
					return module
				end
			end
		end
		object = object.Parent
	until object == nil

	error(OUTPUT_PREFIX .. "Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(context, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error(OUTPUT_PREFIX .. "Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[context] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  ⇒ " .. currentModule.Name
			end

			error(OUTPUT_PREFIX .. "Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				OUTPUT_PREFIX
				.. "Invalid module access! Do you have multiple TS runtimes trying to import this? "
				.. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[context] == module then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

local SIGN = 2 ^ 31
local COMPLEMENT = 2 ^ 32
local function bit_sign(num)
	-- Restores the sign after an unsigned conversion according to 2s complement.
	if bit32.btest(num, SIGN) then
		return num - COMPLEMENT
	else
		return num
	end
end

function TS.bit_lrsh(a, b)
	return bit_sign(bit32.arshift(a, b))
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(func, catch, finally)
	local err, traceback
	local success, exitType, returns = xpcall(
		func,
		function(errInner)
			err = errInner
			traceback = debug.traceback()
		end
	)
	if not success and catch then
		local newExitType, newReturns = catch(err, traceback)
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

return TS
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBXE24C764AE1864FF48ED6AF8ECA91F0C9">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">node_modules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Folder" referent="RBXEC47EB6A9AEA4793BCD68EDA931E6B70">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">@rbxts</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXBF33707253764DF39D0C776C9CE6115A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">compiler-types</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX2AB4979E425B47D3B70B770432B4E793">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">package</string>
								<string name="ScriptGuid">{2C2E0F24-767A-43D9-8B67-3EB06A21A4C4}</string>
								<ProtectedString name="Source"><![CDATA[return {
	author = "roblox-ts",
	description = "",
	devDependencies = {
		["@rbxts/types"] = "^1.0.571",
		["@typescript-eslint/eslint-plugin"] = "^5.10.0",
		["@typescript-eslint/parser"] = "^5.10.0",
		eslint = "^8.7.0",
		["eslint-config-prettier"] = "^8.1.0",
		["eslint-plugin-no-autofix"] = "^1.2.3",
		["eslint-plugin-prettier"] = "^4.0.0",
		["eslint-plugin-simple-import-sort"] = "^8.0.0",
		prettier = "^2.2.1",
		typescript = "^4.2.3",
	},
	files = {"types/*.d.ts"},
	license = "MIT",
	main = "types/core.d.ts",
	name = "@rbxts/compiler-types",
	scripts = {
		eslint = "npx eslint \"types/**/*.d.ts\" --max-warnings 0",
	},
	types = "types/core.d.ts",
	version = "2.0.4-types.0",
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXA778C1A5A09545AF90CC7163F29708D5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">types</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXC8B06230D6CB437680B55ED412EE780A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">cubic-bezier</string>
							<string name="ScriptGuid">{72D7B2F6-6E5E-40B6-B87D-E754D45224E4}</string>
							<ProtectedString name="Source"><![CDATA[-- Smooth Interpolation Curve Generator
-- @author Validark
-- @original https://github.com/gre/bezier-easing
-- 		Copyright (c) 2014 Gaëtan Renaudeau, MIT License (see bottom for full license)
-- @testsite http://cubic-bezier.com/
-- @testsite http://greweb.me/bezier-easing-editor/example/

-- Bezier.new(x1, y1, x2, y2)
-- @param numbers (x1, y1, x2, y2) The control points of your curve
-- @returns function(t [b, c, d])
--	@param number t the time elapsed [0, d]
--	@param number b beginning value being interpolated (default = 0)
--	@param number c change in value being interpolated (equivalent to: ending - beginning) (default = 1)
--	@param number d duration interpolation is occurring over (default = 1)

-- These values are established by empiricism with tests (tradeoff: performance VS precision)
local NEWTON_ITERATIONS = 4
local NEWTON_MIN_SLOPE = 0.001
local SUBDIVISION_PRECISION = 0.0000001
local SUBDIVISION_MAX_ITERATIONS = 10
local K_SPLINE_TABLE_SIZE = 11

local K_SAMPLE_STEP_SIZE = 1 / (K_SPLINE_TABLE_SIZE - 1)

local function Linear(t, b, c, d)
	if d ~= nil then t = t / d end
	return (c or 1)*math.clamp(t, 0, 1) + (b or 0)
end

local Bezier = {}

function Bezier.new(x1, y1, x2, y2)
	-- TS cannot (reasonably) protect against this
	if not (0 <= x1 and x1 <= 1 and 0 <= x2 and x2 <= 1) then error("The x values must be within range [0, 1]") end

	if x1 == y1 and x2 == y2 then
		return Linear
	end

	-- Precompute redundant values
	local e, f = 3*x1, 3*x2
	local g, h, i = 1 - f + e, f - 2*e, 3*(1 - f + e)
	local j, k = 2*h, 3*y1
	local l, m = 1 - 3*y2 + k, 3*y2 - 2*k

	-- Precompute samples table
	local SampleValues = {}
	for a = 0, K_SPLINE_TABLE_SIZE - 1 do
		local z = a*K_SAMPLE_STEP_SIZE
		SampleValues[a] = ((g*z + h)*z + e)*z -- CalcBezier
	end

	return function(t, b, c, d)
		if d ~= nil then t = t / d end
		t = math.clamp(t, 0, 1) -- Make sure the endpoints are correct

		local CurrentSample = K_SPLINE_TABLE_SIZE - 2

		for a = 1, CurrentSample do
			if SampleValues[a] > t then
				CurrentSample = a - 1
				break
			end
		end

		-- Interpolate to provide an initial guess for t
		local IntervalStart = CurrentSample*K_SAMPLE_STEP_SIZE
		local GuessForT = IntervalStart + K_SAMPLE_STEP_SIZE*(t - SampleValues[CurrentSample]) / (SampleValues[CurrentSample + 1] - SampleValues[CurrentSample])
		local InitialSlope = (i*GuessForT + j)*GuessForT + e

		if InitialSlope >= NEWTON_MIN_SLOPE then
			for NewtonRaphsonIterate = 1, NEWTON_ITERATIONS do
				local CurrentSlope = (i*GuessForT + j)*GuessForT + e
				if CurrentSlope == 0 then break end
				GuessForT = GuessForT - (((g*GuessForT + h)*GuessForT + e)*GuessForT - t) / CurrentSlope
			end
		elseif InitialSlope ~= 0 then
			local IntervalStep = IntervalStart + K_SAMPLE_STEP_SIZE

			for BinarySubdivide = 1, SUBDIVISION_MAX_ITERATIONS do
				GuessForT = IntervalStart + 0.5*(IntervalStep - IntervalStart)
				local BezierCalculation = ((g*GuessForT + h)*GuessForT + e)*GuessForT - t

				if BezierCalculation > 0 then
					IntervalStep = GuessForT
				else
					IntervalStart = GuessForT
					BezierCalculation = -BezierCalculation
				end

				if BezierCalculation <= SUBDIVISION_PRECISION then break end
			end
		end

		t = ((l*GuessForT + m)*GuessForT + k)*GuessForT
		return (c or 1)*t + (b or 0)
	end
end

return Bezier

--[[
Copyright (c) 2014 Gaëtan Renaudeau
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
--]]
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXEB2A5D3BED944EA9929764E73C45BDA9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">package</string>
								<string name="ScriptGuid">{663B3C54-B1CD-4527-AA5A-544FBC3A54D6}</string>
								<ProtectedString name="Source"><![CDATA[return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-Libraries/issues",
	},
	description = "A library for generating smooth two-dimensional interpolation curves",
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/cubic-bezier/README.md",
	keywords = {"bezier", "cubic-bezier", "curve", "interpolation", "interpolate", "easing", "ease", "lerp", "tween", "roblox"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/cubic-bezier",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/cubic-bezier",
	},
	scripts = {
		test = "echo \"Error: no test specified\" && exit 1",
	},
	types = "index.d.ts",
	version = "1.1.0",
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX6B703AAC07A24C39BB41924C3E9323D2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">cue</string>
							<string name="ScriptGuid">{A3A4E0C7-2745-4C09-9342-C8815316777C}</string>
							<ProtectedString name="Source"><![CDATA[-- The lightest Event library ever
-- Pretty straightforward
-- @author Validark

local Cue = {}
Cue.__index = Cue

function Cue.new()
	return setmetatable({}, Cue)
end

function Cue:go(...)
	for i = 1, #self do
		coroutine.resume(coroutine.create(self[i]), ...)
	end
end

function Cue:bind(Function)
	self[#self + 1] = Function
end

function Cue:unbind(Function)
	local n = #self

	for i = 1, n do
		if Function == self[i] then
			self[i] = self[n]
			self[n] = nil
			break
		end
	end
end

function Cue:unbindAll()
	for i = 1, #self do
		self[i] = nil
	end
end

return Cue
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXA0D20184849E4583B4F23E3F06AF4741">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">package</string>
								<string name="ScriptGuid">{0D4FB69F-1F9A-48B8-AFFC-30D0232C1D9A}</string>
								<ProtectedString name="Source"><![CDATA[return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-Libraries/issues",
	},
	description = "The fastest and lightest Event object ever made",
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/cue/README.md",
	keywords = {"Roblox", "TypeScript", "roblox-TS", "event", "signal", "connection"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/cue",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/cue",
	},
	scripts = {
		test = "echo \"Error: no test specified\" && exit 1",
	},
	types = "index.d.ts",
	version = "1.0.1",
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX8B3561465C2C49BFA4CF1D590CBCA8C0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">delay-spawn-wait</string>
							<string name="ScriptGuid">{0F51C35A-1EAD-4055-9105-6DF3632A61F5}</string>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local function spawn(callback, ...)
    local bindable = Instance.new("BindableEvent")
    local length = select("#", ...)

    if length == 0 then
        bindable.Event:Connect(callback)
    else
        local args = { ... }
        bindable.Event:Connect(function()
            callback(table.unpack(args, 1, length))
        end)
    end

	bindable:Fire()
	bindable:Destroy()
end

-- uses a min-heap to achieve O(1) check operations and O(log(n)) remove/insert operations
local queue = {}
local len = 0

local connection -- the Heartbeat `RBXScriptConnection | nil`

local function heartbeatStep()
	local clockTick = os.clock()

	repeat
		local current = queue[1]
		if current == nil or current.endTime > clockTick then break end
		local done = len == 1

		if done then
			queue[1] = nil
			len = 0
			connection:Disconnect()
			connection = nil
		else
			local lastNode = queue[len]
			queue[len] = nil
			len = len - 1
			local targetIndex = 1

			while true do
				local childIndex = 2*targetIndex -- leftChild, but this might change to rightChild below
				if childIndex > len then break end
				local minChild = queue[childIndex]
				local rightChildIndex = childIndex + 1

				if rightChildIndex <= len then
					local rightChild = queue[rightChildIndex]
					if rightChild.endTime < minChild.endTime then
						childIndex = rightChildIndex
						minChild = rightChild
					end
				end

				if lastNode.endTime < minChild.endTime then break end
				queue[targetIndex] = minChild
				targetIndex = childIndex
			end

			queue[targetIndex] = lastNode
		end

		local args = current.args
		local callback = current.callback

		if typeof(callback) == "Instance" then
			if args then
				callback:Fire(os.clock() - current.startTime, table.unpack(args, 2, args[1]))
			else
				callback:Fire(os.clock() - current.startTime)
			end
		else
			local bindable = Instance.new("BindableEvent")

			if args then
				bindable.Event:Connect(function(elapsedTime)
					callback(elapsedTime, table.unpack(args, 2, args[1]))
				end)
			else
				bindable.Event:Connect(callback)
			end

			bindable:Fire(os.clock() - current.startTime)
			bindable:Destroy()
		end
	until done
end

local function delay(seconds, callback, ...)
	-- If seconds is nil, -INF, INF, NaN, or less than MINIMUM_DELAY, assume seconds is MINIMUM_DELAY.
	if seconds == nil or not (seconds > 0) or seconds == math.huge then
		seconds = 0
	end

	local startTime = os.clock()
	local endTime = startTime + seconds
	local length = select("#", ...)

	if connection == nil then -- first is nil when connection is nil
		connection = RunService.Heartbeat:Connect(heartbeatStep)
	end

	local node = {
		callback = callback,
		startTime = startTime,
		endTime = endTime,
		args = length > 0 and { length + 1, ... }
	}

	local targetIndex = len + 1
	len = targetIndex

	while true do
		local parentIndex = (targetIndex - targetIndex % 2) / 2
		if parentIndex < 1 then break end
		local parentNode = queue[parentIndex]
		if parentNode.endTime < node.endTime then break end
		queue[targetIndex] = parentNode
		targetIndex = parentIndex
	end

	queue[targetIndex] = node
end

local function wait(seconds)
    local bindable = Instance.new("BindableEvent")
    delay(seconds, bindable)
    local elapsedTime = bindable.Event:Wait()
    bindable:Destroy()
    return elapsedTime
end

return {
    spawn = spawn;
    delay = delay;
    wait = wait;
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX8CD184C52B4E4C63BF2D03AD8785449B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">package</string>
								<string name="ScriptGuid">{0693F7EE-EADD-41D6-99E6-1FE3C3C3FF5C}</string>
								<ProtectedString name="Source"><![CDATA[return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-Libraries/issues",
	},
	bundledDependencies = {},
	description = "Replacement for the default delay, spawn, and wait functions",
	files = {"init.lua", "index.d.ts", "README.md"},
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/delay-spawn-wait/README.md",
	keywords = {"yield", "wait", "spawn", "delay"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/delay-spawn-wait",
	peerDependencies = {
		["@rbxts/compiler-types"] = "^1.0.0-beta.15.0",
		["@rbxts/types"] = "^1.0.441",
	},
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/delay-spawn-wait",
	},
	scripts = {
	},
	types = "index.d.ts",
	version = "2.0.0",
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX68C0C8232A55487F9131110D3571F278">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">easing-functions</string>
							<string name="ScriptGuid">{AFD57341-35F2-4A28-9BC1-14D47D461D21}</string>
							<ProtectedString name="Source"><![CDATA[-- Prescribed Material design Beziers and optimized Robert Penner functions
-- @author Robert Penner

local Bezier = require(assert(script.Parent:FindFirstChild("cubic-bezier"), "[@rbxts/easing-functions] Please `npm install @rbxts/cubic-bezier` to use this library."))

-- @specs https://material.io/design/motion/speed.html#easing
local Sharp = Bezier.new(0.4, 0, 0.6, 1)
local Standard = Bezier.new(0.4, 0, 0.2, 1)
local Acceleration = Bezier.new(0.4, 0, 1, 1)
local Deceleration = Bezier.new(0, 0, 0.2, 1)

--[[
	Disclaimer for Robert Penner's Easing Equations license:

	TERMS OF USE - EASING EQUATIONS

	Open source under the BSD License.

	Copyright © 2001 Robert Penner
	All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	* Neither the name of the author nor the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
]]

-- For all easing functions:
-- t = elapsed time
-- b = beginning value
-- c = change in value same as: ending - beginning
-- d = duration (total time)

-- Where applicable
-- a = amplitude
-- p = period

local sin = math.sin
local cos = math.cos
local abs = math.abs
local asin = math.asin
local exp = math.exp

local SoftSpringpi = -3.2*3.1415926535897932
local Springpi = 2*SoftSpringpi

local function Linear(t, b, c, d)
	return c * t / d + b
end

local function Smooth(t, b, c, d)
	t = t / d
	return c * t * t * (3 - 2*t) + b
end

local function Smoother(t, b, c, d)
	t = t / d
	return c*t*t*t * (t * (6*t - 15) + 10) + b
end

-- Arceusinator's Easing Functions
local function RevBack(t, b, c, d)
	t = 1 - t / d
	return c*(1 - (sin(t*1.5707963267948966) + (sin(t*3.1415926535897932) * (cos(t*3.1415926535897932) + 1)*0.5))) + b
end

local function RidiculousWiggle(t, b, c, d)
	t = t / d
	return c*sin(sin(t*3.1415926535897932)*1.5707963267948966) + b
end

-- YellowTide's Easing Functions
local function Spring(t, b, c, d)
	t = t / d
	return (1 + (-exp(-6.9 * t) * cos(Springpi*t))) * c + b
end

local function SoftSpring(t, b, c, d)
	t = t / d
	return (1 + (-exp(-7.5 * t) * cos(SoftSpringpi*t))) * c + b
end
-- End of YellowTide's functions

local function InQuad(t, b, c, d)
	t = t / d
	return c * t * t + b
end

local function OutQuad(t, b, c, d)
	t = t / d
	return -c * t * (t - 2) + b
end

local function InOutQuad(t, b, c, d)
	t = t / d * 2

	if t < 1 then
		return c * 0.5 * t * t + b
	else
		return -c * 0.5 * ((t - 1) * (t - 3) - 1) + b
	end
end

local function OutInQuad(t, b, c, d)
	if t < d * 0.5 then
		t = 2 * t / d
		return -0.5 * c * t * (t - 2) + b
	else
		t = ((t * 2) - d) / d
		c = 0.5 * c
		return c * t * t + b + c
	end
end

local function InCubic(t, b, c, d)
	t = t / d
	return c * t * t * t + b
end

local function OutCubic(t, b, c, d)
	t = t / d - 1
	return c * (t * t * t + 1) + b
end

local function InOutCubic(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t + b
	else
		t = t - 2
		return c * 0.5 * (t * t * t + 2) + b
	end
end

local function OutInCubic(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * 0.5 * (t * t * t + 1) + b
	else
		t = ((t * 2) - d) / d
		c = c * 0.5
		return c * t * t * t + b + c
	end
end

local function InQuart(t, b, c, d)
	t = t / d
	return c * t * t * t * t + b
end

local function OutQuart(t, b, c, d)
	t = t / d - 1
	return -c * (t * t * t * t - 1) + b
end

local function InOutQuart(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t * t + b
	else
		t = t - 2
		return -c * 0.5 * (t * t * t * t - 2) + b
	end
end

local function OutInQuart(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		c = c * 0.5
		return -c * (t * t * t * t - 1) + b
	else
		t = ((t * 2) - d) / d
		c = c * 0.5
		return c * t * t * t * t + b + c
	end
end

local function InQuint(t, b, c, d)
	t = t / d
	return c * t * t * t * t * t + b
end

local function OutQuint(t, b, c, d)
	t = t / d - 1
	return c * (t * t * t * t * t + 1) + b
end

local function InOutQuint(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * t * t * t * t * t + b
	else
		t = t - 2
		return c * 0.5 * (t * t * t * t * t + 2) + b
	end
end

local function OutInQuint(t, b, c, d)
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * 0.5 * (t * t * t * t * t + 1) + b
	else
		t = ((t * 2) - d) / d
		c = c * 0.5
		return c * t * t * t * t * t + b + c
	end
end

local function InSine(t, b, c, d)
	return -c * cos(t / d * 1.5707963267948966) + c + b
end

local function OutSine(t, b, c, d)
	return c * sin(t / d * 1.5707963267948966) + b
end

local function InOutSine(t, b, c, d)
	return -c * 0.5 * (cos(3.1415926535897932 * t / d) - 1) + b
end

local function OutInSine(t, b, c, d)
	c = c * 0.5
	if t < d * 0.5 then
		return c * sin(t * 2 / d * 1.5707963267948966) + b
	else
		return -c * cos(((t * 2) - d) / d * 1.5707963267948966) + 2 * c + b
	end
end

local function InExpo(t, b, c, d)
	if t == 0 then
		return b
	else
		return c * 1024 ^ (t / d - 1) + b - c * 0.001
	end
end

local function OutExpo(t, b, c, d)
	if t == d then
		return b + c
	else
		return c * 1.001 * (1 - exp(-6.9314718055994531 * (t / d))) + b
	end
end

local function InOutExpo(t, b, c, d)
	t = t / d * 2

	if t == 0 then
		return b
	elseif t == 2 then
		return b + c
	elseif t < 1 then
		return c * 0.5 * 1024 ^ (t - 1) + b - c * 0.0005
	else
		return c * 0.50025 * (2 - exp(-6.9314718055994531 * (t - 1))) + b
	end
end

local function OutInExpo(t, b, c, d)
	c = c * 0.5
	if t < d * 0.5 then
		if t * 2 == d then
			return b + c
		else
			return c * 1.001 * (1 - exp(13.8629436111989062 * t / d)) + b
		end
	else
		if t * 2 - d == 0 then
			return b + c
		else
			return c * 1024 ^ ((t * 2 - d) / d - 1) + b + c - c * 0.001
		end
	end
end

local function InCirc(t, b, c, d)
	t = t / d
	return -c * ((1 - t * t) ^ 0.5 - 1) + b
end

local function OutCirc(t, b, c, d)
	t = t / d - 1
	return c * (1 - t * t) ^ 0.5 + b
end

local function InOutCirc(t, b, c, d)
	t = t / d * 2
	if t < 1 then
		return -c * 0.5 * ((1 - t * t) ^ 0.5 - 1) + b
	else
		t = t - 2
		return c * 0.5 * ((1 - t * t) ^ 0.5 + 1) + b
	end
end

local function OutInCirc(t, b, c, d)
	c = c * 0.5
	if t < d * 0.5 then
		t = t * 2 / d - 1
		return c * (1 - t * t) ^ 0.5 + b
	else
		t = (t * 2 - d) / d
		return -c * ((1 - t * t) ^ 0.5 - 1) + b + c
	end
end

local function InElastic(t, b, c, d, a, p)
	t = t / d - 1
	if t == -1 then
		return b
	else
		if t == 0 then
			return b + c
		else
			p = p or d * 0.3
			local abs_c

			if c < 0 then
				abs_c = -c
			else
				abs_c = c
			end

			if a == nil or a < abs_c then
				return -(c * 1024 ^ t * sin((t * d - p * 0.25) * 6.2831853071795864 / p)) + b
			else
				return -(a * 1024 ^ t * sin((t * d - p / 6.2831853071795864 * asin(c/a)) * 6.2831853071795864 / p)) + b
			end
		end
	end
end

local function OutElastic(t, b, c, d, a, p)
	t = t / d
	if t == 0 then
		return b
	else
		if t == 1 then
			return b + c
		else
			p = p or d * 0.3
			local abs_c

			if c < 0 then
				abs_c = -c
			else
				abs_c = c
			end

			if a == nil or a < abs_c then
				return c * exp(-6.9314718055994531 * t) * sin((t * d - p * 0.25) * 6.2831853071795864 / p) + c + b
			else
				return a * exp(-6.9314718055994531 * t) * sin((t * d - p / 6.2831853071795864 * asin(c / a)) * 6.2831853071795864 / p) + c + b
			end
		end
	end
end

local function InOutElastic(t, b, c, d, a, p)
	if t == 0 then
		return b
	end

	t = t / d * 2 - 1

	if t == 1 then
		return b + c
	end

	p = p or d * 0.45
	a = a or 0

	local s
	local abs_c

	if c < 0 then
		abs_c = -c
	else
		abs_c = c
	end

	if a == nil or a < abs_c then
		a = c
		s = p * 0.25
	else
		s = p / 6.2831853071795864 * asin(c / a)
	end

	if t < 1 then
		return -0.5 * a * 1024 ^ t * sin((t * d - s) * 6.2831853071795864 / p) + b
	else
		return a * exp(-6.9314718055994531 * t) * sin((t * d - s) * 6.2831853071795864 / p ) * 0.5 + c + b
	end
end

local function OutInElastic(t, b, c, d, a, p)
	if t < d * 0.5 then
		return OutElastic(t * 2, b, c * 0.5, d, a, p)
	else
		return InElastic(t * 2 - d, b + c * 0.5, c * 0.5, d, a, p)
	end
end

local function InBack(t, b, c, d, s)
	s = s or 1.70158
	t = t / d
	return c * t * t * ((s + 1) * t - s) + b
end

local function OutBack(t, b, c, d, s)
	s = s or 1.70158
	t = t / d - 1
	return c * (t * t * ((s + 1) * t + s) + 1) + b
end

local function InOutBack(t, b, c, d, s)
	s = (s or 1.70158) * 1.525
	t = t / d * 2
	if t < 1 then
		return c * 0.5 * (t * t * ((s + 1) * t - s)) + b
	else
		t = t - 2
		return c * 0.5 * (t * t * ((s + 1) * t + s) + 2) + b
	end
end

local function OutInBack(t, b, c, d, s)
	c = c * 0.5
	s = s or 1.70158
	if t < d * 0.5 then
		t = (t * 2) / d - 1
		return c * (t * t * ((s + 1) * t + s) + 1) + b
	else
		t = ((t * 2) - d) / d
		return c * t * t * ((s + 1) * t - s) + b + c
	end
end

local function OutBounce(t, b, c, d)
	t = t / d
	if t < 1 / 2.75 then
		return c * (7.5625 * t * t) + b
	elseif t < 2 / 2.75 then
		t = t - (1.5 / 2.75)
		return c * (7.5625 * t * t + 0.75) + b
	elseif t < 2.5 / 2.75 then
		t = t - (2.25 / 2.75)
		return c * (7.5625 * t * t + 0.9375) + b
	else
		t = t - (2.625 / 2.75)
		return c * (7.5625 * t * t + 0.984375) + b
	end
end

local function InBounce(t, b, c, d)
	return c - OutBounce(d - t, 0, c, d) + b
end

local function InOutBounce(t, b, c, d)
	if t < d * 0.5 then
		return InBounce(t * 2, 0, c, d) * 0.5 + b
	else
		return OutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b
	end
end

local function OutInBounce(t, b, c, d)
	if t < d * 0.5 then
		return OutBounce(t * 2, b, c * 0.5, d)
	else
		return InBounce(t * 2 - d, b + c * 0.5, c * 0.5, d)
	end
end

return {
	Standard = Standard;
	Deceleration = Deceleration;
	Acceleration = Acceleration;
	Sharp = Sharp;

	Linear = Linear;

	InSine = InSine;
	OutSine = OutSine;
	InOutSine = InOutSine;
	OutInSine = OutInSine;

	InBack = InBack;
	OutBack = OutBack;
	InOutBack = InOutBack;
	OutInBack = OutInBack;

	InQuad = InQuad;
	OutQuad = OutQuad;
	InOutQuad = InOutQuad;
	OutInQuad = OutInQuad;

	InQuart = InQuart;
	OutQuart = OutQuart;
	InOutQuart = InOutQuart;
	OutInQuart = OutInQuart;

	InQuint = InQuint;
	OutQuint = OutQuint;
	InOutQuint = InOutQuint;
	OutInQuint = OutInQuint;

	InBounce = InBounce;
	OutBounce = OutBounce;
	InOutBounce = InOutBounce;
	OutInBounce = OutInBounce;

	InElastic = InElastic;
	OutElastic = OutElastic;
	InOutElastic = InOutElastic;
	OutInElastic = OutInElastic;

	InCirc = InCirc;
	OutCirc = OutCirc;
	InOutCirc = InOutCirc;
	OutInCirc = OutInCirc;

	InCubic = InCubic;
	OutCubic = OutCubic;
	InOutCubic = InOutCubic;
	OutInCubic = OutInCubic;

	InExpo = InExpo;
	OutExpo = OutExpo;
	InOutExpo = InOutExpo;
	OutInExpo = OutInExpo;

	Smooth = Smooth;
	Smoother = Smoother;
	RevBack = RevBack;
	RidiculousWiggle = RidiculousWiggle;
	Spring = Spring;
	SoftSpring = SoftSpring;
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX4344ADA6077F4414A0C96D43ECD390F6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">package</string>
								<string name="ScriptGuid">{A2F72986-B18F-45E7-81D8-7F679B2814D1}</string>
								<ProtectedString name="Source"><![CDATA[return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-libraries/issues",
	},
	bundledDependencies = {},
	dependencies = {
		["@rbxts/cubic-bezier"] = "^1.0.2",
	},
	description = "A bunch of reuseable Easing Functions, including those from the Material Design specification and Robert Penner.",
	files = {"init.lua", "index.d.ts", "README.md"},
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/easing-functions/README.md",
	keywords = {"bezier", "cubic-bezier", "curve", "interpolation", "interpolate", "easing", "ease", "lerp", "tween", "roblox"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/easing-functions",
	peerDependencies = {
		["@rbxts/cubic-bezier"] = "^1.0.2",
	},
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/easing-functions",
	},
	scripts = {
		test = "echo \"Error: no test specified\" && exit 1",
	},
	typings = "index.d.ts",
	version = "1.1.0",
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXA9075C8CDC5E4860AEB949C8100CACD2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">lerp-functions</string>
							<string name="ScriptGuid">{9143B5FE-654C-44DB-8935-C5CC68018D74}</string>
							<ProtectedString name="Source"><![CDATA[local function sortByTime(a, b)
	return a.Time < b.Time
end

-- Mostly ripped off from https://github.com/Fraktality/anim/blob/master/anim.lua
-- Copyright 2017 Parker Stebbins <parker@fractality.io>
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software
-- and associated documentation files (the "Software"), to deal in the Software without
-- restriction, including without limitation the rights to use, copy, modify, merge, publish,
-- distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
-- Software is furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all copies or
-- substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
-- BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
-- DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--
local Lerps = {}

-- bool
function Lerps.boolean(v0, v1)
	return function(t)
		if t < 0.5 then
			return v0
		else
			return v1
		end
	end
end

-- number
function Lerps.number(v0, v1)
	local dv = v1 - v0
	return function(t)
		return v0 + dv*t
	end
end

do -- Color3
	local C3 = Color3.new
	local black = C3(0, 0, 0)

	function Lerps.Color3(c0, c1)
		local u0, v0, u1, v1, l0, l1

		-- Convert from linear RGB to scaled CIELUV (RgbToLuv13)
		local r, g, b = c0.r, c0.g, c0.b
		-- Apply inverse gamma correction

		if r < 0.0404482362771076 then
			r = r / 12.92
		else
			r = 0.87941546140213*(r + 0.055)^2.4
		end

		if g < 0.0404482362771076 then
			g = g / 12.92
		else
			g = 0.87941546140213*(g + 0.055)^2.4
		end

		if b < 0.0404482362771076 then
			b = b / 12.92
		else
			b = 0.87941546140213*(b + 0.055)^2.4
		end

		-- sRGB->XYZ->CIELUV
		local y = 0.2125862307855956*r + 0.71517030370341085*g + 0.0722004986433362*b
		local z = 3.6590806972265883*r + 11.4426895800574232*g + 4.1149915024264843*b

		if y > 0.008856451679035631 then
			l0 = 116*y^(1/3) - 16
		else
			l0 = 903.296296296296*y
		end

		if z > 1e-15 then
			u0, v0 = l0*(0.9257063972951867*r - 0.8333736323779866*g - 0.09209820666085898*b)/z, l0*(9*y/z - 0.46832)
		else
			u0, v0 = -0.19783*l0, -0.46832*l0
		end

		-- Convert from linear RGB to scaled CIELUV (RgbToLuv13)
		r, g, b = c1.r, c1.g, c1.b
		-- Apply inverse gamma correction

		if r < 0.0404482362771076 then
			r = r / 12.92
		else
			r = 0.87941546140213*(r + 0.055)^2.4
		end

		if g < 0.0404482362771076 then
			g = g / 12.92
		else
			g = 0.87941546140213*(g + 0.055)^2.4
		end

		if b < 0.0404482362771076 then
			b = b / 12.92
		else
			b = 0.87941546140213*(b + 0.055)^2.4
		end

		-- sRGB->XYZ->CIELUV
		y = 0.2125862307855956*r + 0.71517030370341085*g + 0.0722004986433362*b
		z = 3.6590806972265883*r + 11.4426895800574232*g + 4.1149915024264843*b

		if y > 0.008856451679035631 then
			l1 = 116*y^(1/3) - 16
		else
			l1 = 903.296296296296*y
		end

		if z > 1e-15 then
			u1, v1 = l1*(0.9257063972951867*r - 0.8333736323779866*g - 0.09209820666085898*b)/z, l1*(9*y/z - 0.46832)
		else
			u1, v1 = -0.19783*l1, -0.46832*l1
		end

		return function(t)
			local l = (1 - t)*l0 + t*l1
			if l < 0.0197955 then
				return black
			end

			local u = ((1 - t)*u0 + t*u1)/l + 0.19783
			local v = ((1 - t)*v0 + t*v1)/l + 0.46832

			local y = (l + 16)/116

			if y > 0.206896551724137931 then
				y = y*y*y
			else
				y = 0.12841854934601665*y - 0.01771290335807126
			end

			local x = y*u/v
			local z = y*((3 - 0.75*u)/v - 5)

			local r =  7.2914074*x - 1.5372080*y - 0.4986286*z
			local g = -2.1800940*x + 1.8757561*y + 0.0415175*z
			local b =  0.1253477*x - 0.2040211*y + 1.0569959*z

			if r < 0 and r < g and r < b then
				r, g, b = 0, g - r, b - r
			elseif g < 0 and g < b then
				r, g, b = r - g, 0, b - g
			elseif b < 0 then
				r, g, b = r - b, g - b, 0
			end

			if r < 3.1306684425e-3 then
				r = 12.92*r
			else
				r = 1.055*r^(1 / 2.4) - 0.055
			end

			if g < 3.1306684425e-3 then
				g = 12.92*g
			else
				g = 1.055*g^(1 / 2.4) - 0.055
			end

			if b < 3.1306684425e-3 then
				b = 12.92*b
			else
				b = 1.055*b^(1 / 2.4) - 0.055
			end

			if r < 0 then
				r = 0
			elseif r > 1 then
				r = 1
			end

			if g < 0 then
				g = 0
			elseif g > 1 then
				g = 1
			end

			if b < 0 then
				b = 0
			elseif b > 1 then
				b = 1
			end

			return C3(r, g, b)
		end
	end
end

do -- string
	local s_match = string.match
	local s_format = string.format
	local atof = tonumber

	function Lerps.string(v0, v1)
		local n0, d do
			local sign0, h0, m0, s0 = s_match(v0, '^([+-]?)(%d*):[+-]?(%d*):[+-]?(%d*)$')
			local sign1, h1, m1, s1 = s_match(v1, '^([+-]?)(%d*):[+-]?(%d*):[+-]?(%d*)$')
			if sign0 and sign1 then
				n0       = 3600*(atof(h0) or 0) + 60*(atof(m0) or 0) + (atof(s0) or 0)
				local n1 = 3600*(atof(h1) or 0) + 60*(atof(m1) or 0) + (atof(s1) or 0)
				if sign0 == '-' then
					n0 = -n0
				end
				d = (43200 + (sign1 ~= '-' and n1 or -n1) - n0)%86400 - 43200
			else
				error('Invalid TimeOfDay string', 4)
			end
		end

		return function(t)
			local fs = (n0 + d*t)%86400
			local s = fs > 0 and fs or -fs
			return s_format(
				fs < 0 and '-%.2u:%.2u:%.2u' or '%.2u:%.2u:%.2u',
				(s - s%3600)/3600,
				(s%3600 - s%60)/60,
				s%60
			)
		end
	end
end

do -- CFrame
	local Slerp = CFrame.new().lerp
	function Lerps.CFrame(v0, v1)
		return function(t)
			return Slerp(v0, v1, t)
		end
	end
end

do -- NumberRange
	local NR = NumberRange.new
	function Lerps.NumberRange(v0, v1)
		local min0, max0 = v0.Min, v0.Max
		local dmin, dmax = v1.Min - min0, v1.Max - max0
		v0, v1 = nil, nil
		return function(t)
			return NR(min0 + t*dmin, max0 + t*dmax)
		end
	end
end

do -- NumberSequenceKeypoint
	local NSK = NumberSequenceKeypoint.new
	function Lerps.NumberSequenceKeypoint(v0, v1)
		local t0, v0, e0 = v0.Time, v0.Value, v0.Envelope
		local dt, dv, de = v1.Time - t0, v1.Value - v0, v1.Envelope - e0
		v1 = nil
		return function(t)
			return NSK(t0 + t*dt, v0 + t*dv, e0 + t*de)
		end
	end
end

do -- PhysicalProperties
	local PP = PhysicalProperties.new
	function Lerps.PhysicalProperties(v0, v1)
		local d0, e0, ew0, f0, fw0 =
			v0.Density,
			v0.Elasticity,
			v0.ElasticityWeight,
			v0.Friction,
			v0.FrictionWeight
		local dd, de, dew, df, dfw =
			v1.Density - d0,
			v1.Elasticity - e0,
			v1.ElasticityWeight - ew0,
			v1.Friction - f0,
			v1.FrictionWeight - fw0
		v0, v1 = nil, nil
		return function(t)
			return PP(d0 + t*dd, e0 + t*de, ew0 + t*dew, f0 + t*df, fw0 + t*dfw)
		end
	end
end

do -- Ray
	local R = Ray.new
	local V3 = Vector3.new
	function Lerps.Ray(v0, v1)
		local o0, d0, o1, d1 =
			v0.Origin, v0.Direction,
			v1.Origin, v1.Direction
		local ox0, oy0, oz0, dx0, dy0, dz0, dx1, dy1, dz1 =
			o0.x, o0.y, o0.z,
			d0.x, d0.y, d0.z,
			d1.x, d1.y, d1.z
		local dox, doy, doz, ddx, ddy, ddz =
			o1.x - ox0, o1.y - oy0, o1.z - oz0,
			d1.x - dx0, d1.y - dy0, d1.z - dz0
		v0, v1, o0, d0, o1, d1 = nil, nil, nil, nil, nil, nil
		return function(t)
			return R(
				V3(ox0 + t*dox, oy0 + t*doy, oz0 + t*doz),
				V3(dx0 + t*ddx, dy0 + t*ddy, dz0 + t*ddz)
			)
		end
	end
end

do
	newRect = Rect.new

	function Lerps.Rect(v0, v1)
		local sc, of = v0.Min.X, v0.Min.Y
		local dsc, dof = v1.Min.X - sc, v1.Min.Y - of
		local sc2, of2 = v0.Max.X, v0.Max.Y
		local dsc2, dof2 = v1.Max.X - sc2, v1.Max.Y - of2
		v0, v1 = nil, nil

		return function(t)
			return newRect(
				sc + t*dsc, of + t*dof,
				sc2 + t*dsc2, of2 + t*dof2
			)
		end
	end
end

do -- UDim
	local UD = UDim.new
	function Lerps.UDim(v0, v1)
		local sc, of = v0.Scale, v0.Offset
		local dsc, dof = v1.Scale - sc, v1.Offset - of
		v0, v1 = nil, nil
		return function(t)
			return UD(sc + t*dsc, of + t*dof)
		end
	end
end

do -- UDim2
	local Lerp = UDim2.new().Lerp
	function Lerps.UDim2(v0, v1)
		return function(t)
			return Lerp(v0, v1, t)
		end
	end
end

do -- Vector2
	local V2 = Vector2.new
	function Lerps.Vector2(v0, v1)
		local x, y = v0.x, v0.y
		local dx, dy = v1.x - x, v1.y - y
		v0, v1 = nil, nil
		return function(t)
			return V2(x + t*dx, y + t*dy)
		end
	end
end

do -- Vector3
	local V3 = Vector3.new
	function Lerps.Vector3(v0, v1)
		local x, y, z = v0.x, v0.y, v0.z
		local dx, dy, dz = v1.x - x, v1.y - y, v1.z - z
		v0, v1 = nil, nil
		return function(t)
			return V3(x + t*dx, y + t*dy, z + t*dz)
		end
	end
end

do -- ColorSequence
	local newColorSequence = ColorSequence.new
	local Color3Lerp = Lerps.Color3

	function Lerps.ColorSequence(start, finish)
		local l1 = Color3Lerp(start[1], finish[1])
		local l2 = Color3Lerp(start[2], finish[2])

		return function(alpha)
			return newColorSequence(l1(alpha), l2(alpha))
		end
	end
end

do -- Region3
	local newRegion3 = Region3.new
	local newVector3 = Vector3.new

	function Lerps.Region3(start, finish) -- @author Sharksie
		local start1 = start.CFrame * (-start.Size*0.5)
		local start2 = start.CFrame * ( start.Size*0.5)

		local finish1 = finish.CFrame * (-finish.Size*0.5)
		local finish2 = finish.CFrame * ( finish.Size*0.5)

		local change1 = finish1 - start1
		local change2 = finish2 - start2

		return function(alpha)
			local imin = start1 + alpha * change1
			local imax = start2 + alpha * change2

			local iminx = imin.x
			local imaxx = imax.x

			local iminy = imin.y
			local imaxy = imax.y

			local iminz = imin.z
			local imaxz = imax.z

			local x1, x2
			local y1, y2
			local z1, z2

			if iminx < imaxx then
				x1 = iminx
				x2 = imaxx
			else
				x1 = imaxx
				x2 = iminx
			end

			if iminy < imaxy then
				y1 = iminy
				y2 = imaxy
			else
				y1 = imaxy
				y2 = iminy
			end

			if iminz < imaxz then
				z1 = iminz
				z2 = imaxz
			else
				z1 = imaxz
				z2 = iminz
			end

			return newRegion3(
				newVector3(x1, y1, z1),
				newVector3(x2, y2, z2)
			)
		end
	end;
end

do
	function Lerps.NumberSequence(start, finish)
		return function(alpha)
			-- @author Sharksie

			-- For each point on each line, find the values of the other sequence at that point in time through interpolation
			-- 	then interpolate between the known value and the learned value
			-- 	then use that value to create a new keypoint at the time
			-- 	then build a new sequence using all the keypoints generated

			local keypoints = {}
			local addedTimes = {}

			for i, ap in next, start.Keypoints do
				local closestAbove, closestBelow

				for i, bp in next, finish.Keypoints do
					if bp.Time == ap.Time then
						closestAbove, closestBelow = bp, bp
						break
					elseif bp.Time < ap.Time and (closestBelow == nil or bp.Time > closestBelow.Time) then
						closestBelow = bp
					elseif bp.Time > ap.Time and (closestAbove == nil or bp.Time < closestAbove.Time) then
						closestAbove = bp
					end
				end

				local bValue, bEnvelope
				if closestAbove == closestBelow then
					bValue, bEnvelope = closestAbove.Value, closestAbove.Envelope
				else
					local p = (ap.Time - closestBelow.Time)/(closestAbove.Time - closestBelow.Time)
					bValue = (closestAbove.Value - closestBelow.Value)*p + closestBelow.Value
					bEnvelope = (closestAbove.Envelope - closestBelow.Envelope)*p + closestBelow.Envelope
				end
				local interValue = (bValue - ap.Value)*alpha + ap.Value
				local interEnvelope = (bEnvelope - ap.Envelope)*alpha + ap.Envelope
				local interp = NumberSequenceKeypoint.new(ap.Time, interValue, interEnvelope)

				table.insert(keypoints, interp)

				addedTimes[ap.Time] = true
			end

			for i, bp in next, finish.Keypoints do
				if not addedTimes[bp.Time] then
					local closestAbove, closestBelow

					for i, ap in next, start.Keypoints do
						if ap.Time == bp.Time then
							closestAbove, closestBelow = ap, ap
							break
						elseif ap.Time < bp.Time and (closestBelow == nil or ap.Time > closestBelow.Time) then
							closestBelow = ap
						elseif ap.Time > bp.Time and (closestAbove == nil or ap.Time < closestAbove.Time) then
							closestAbove = ap
						end
					end

					local aValue, aEnvelope
					if closestAbove == closestBelow then
						aValue, aEnvelope = closestAbove.Value, closestAbove.Envelope
					else
						local p = (bp.Time - closestBelow.Time)/(closestAbove.Time - closestBelow.Time)
						aValue = (closestAbove.Value - closestBelow.Value)*p + closestBelow.Value
						aEnvelope = (closestAbove.Envelope - closestBelow.Envelope)*p + closestBelow.Envelope
					end
					local interValue = (bp.Value - aValue)*alpha + aValue
					local interEnvelope = (bp.Envelope - aEnvelope)*alpha + aEnvelope
					local interp = NumberSequenceKeypoint.new(bp.Time, interValue, interEnvelope)

					table.insert(keypoints, interp)
				end
			end

			table.sort(keypoints, sortByTime)

			return NumberSequence.new(keypoints)
		end
	end
end

return Lerps
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXFB3BF92BE94146EEB486594B62DC1509">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">package</string>
								<string name="ScriptGuid">{C34C8ABC-F987-4349-9672-2CC1A3B4B5FC}</string>
								<ProtectedString name="Source"><![CDATA[return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-Libraries/issues",
	},
	dependencies = {
		["@rbxts/types"] = "^1.0.227",
	},
	description = "Interpolation functions",
	files = {"init.lua", "index.d.ts", "README.md"},
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/lerp-functions/README.md",
	keywords = {"bezier", "cubic-bezier", "curve", "interpolation", "interpolate", "easing", "ease", "lerp", "tween", "roblox"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/lerp-functions",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/lerp-functions",
	},
	scripts = {
		test = "echo \"Error: no test specified\" && exit 1",
	},
	types = "index.d.ts",
	version = "1.0.2",
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXE3958E11F8AA461E82A5D3E8B1350DB0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">tween</string>
							<string name="ScriptGuid">{FFE90562-8F39-4A86-B95D-373036961F3E}</string>
							<ProtectedString name="Source"><![CDATA[local Lerps = require(assert(script.Parent:FindFirstChild("lerp-functions"), "[@rbxts/tween] Please install @rbxts/lerp-functions to use this library."))

local Tween = {
	Running = false;
	ElapsedTime = 0;
}
Tween.__index = Tween

local RunService = game:GetService("RunService")
local Heartbeat = RunService.Heartbeat
local RenderStepped = RunService.RenderStepped

function Tween:Play()
	if not self.Running then
		local RenderEvent

		if self.ValueType == "CFrame" then
			RenderEvent = RenderStepped
		else
			RenderEvent = Heartbeat
		end

		self.Connection = RenderEvent:Connect(self.Interpolator)
		self.Running = true
	end

	return self
end

function Tween:Pause()
	if self.Running then
		self.Connection:Disconnect()
		self.Running = false
	end

	return self
end

function Tween:Cancel()
	self.ElapsedTime = 0
	return self:Pause()
end

function Tween:Wait()
	local RenderEvent

	if self.ValueType == "CFrame" then
		RenderEvent = RenderStepped
	else
		RenderEvent = Heartbeat
	end

	while self.Running do RenderEvent:Wait() end
	return self
end

local function MakeTween(Duration, EasingFunction, Callback, InitialValue, EndValue, v1, v2)
	if InitialValue == nil then
		InitialValue = 0
		EndValue = 1
	end

	local ValueType = typeof(InitialValue)
	local LerpFunction = Lerps[ValueType](InitialValue, EndValue)

	local self = setmetatable({
		Duration = Duration;
		ValueType = ValueType;
	}, Tween)

	function self.Interpolator(Step)
		local ElapsedTime = self.ElapsedTime + Step
		self.ElapsedTime = ElapsedTime

		if Duration > ElapsedTime then
			-- Because of the way doubles are implemented,
			-- they can hold more unique values between 0 and 1 than any other numbers.
			-- To take advantage of this precision, we shouldn't try to get smart about
			-- changing the beginning/change parameters here
			Callback(LerpFunction(EasingFunction(ElapsedTime, 0, 1, Duration, v1, v2)))
		else
			Callback(EndValue)
			self:Pause()
		end
	end

	return self:Play()
end

return {
	Tween = MakeTween;
	default = MakeTween;
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX6A8E3C1C63234888BAC0EFDB46AF2326">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">package</string>
								<string name="ScriptGuid">{EE03E6FE-5143-47C8-9DF5-452033861522}</string>
								<ProtectedString name="Source"><![CDATA[return {
	author = "Validark",
	bugs = {
		url = "https://github.com/Validark/Roblox-TS-Libraries/issues",
	},
	bundledDependencies = {},
	dependencies = {
		["@rbxts/cubic-bezier"] = "^1.0.2",
		["@rbxts/easing-functions"] = "^1.0.0",
		["@rbxts/lerp-functions"] = "^1.0.0",
	},
	description = "A library for writing efficient, simple interpolation code",
	devDependencies = {
		["@rbxts/compiler-types"] = "^2.0.2-types.0",
		["@rbxts/types"] = "^1.0.641",
	},
	files = {"init.lua", "index.d.ts", "README.md"},
	homepage = "https://github.com/Validark/Roblox-TS-Libraries/blob/master/tween/README.md",
	keywords = {"bezier", "cubic-bezier", "curve", "interpolation", "interpolate", "easing", "ease", "lerp", "tween", "roblox"},
	license = "ISC",
	main = "init.lua",
	name = "@rbxts/tween",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "https://github.com/Validark/Roblox-TS-Libraries/tree/master/tween",
	},
	scripts = {
		test = "echo \"Error: no test specified\" && exit 1",
	},
	types = "index.d.ts",
	version = "1.0.5",
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXF3A8B380875E45B8A9A793D5DD25FBD8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">types</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXA07F8C7DDA1B4597A7A33528B153DF67">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">include</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="Folder" referent="RBX992A0F7631AB4C02952EBE884E83E379">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">generated</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX44154838A0914803B0AB706E744DCA1F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">package</string>
								<string name="ScriptGuid">{0F96A45F-03C2-4D17-B2AA-C469E229213E}</string>
								<ProtectedString name="Source"><![CDATA[return {
	author = "roblox-ts",
	bugs = {
		url = "https://github.com/roblox-ts/types/issues",
	},
	dependencies = {
	},
	description = "TypeScript typings for the Roblox platform. Partially handwritten and partially automatically generated.",
	homepage = "https://github.com/roblox-ts/types#readme",
	keywords = {"types", "Roblox", "typescript"},
	license = "MIT",
	main = "include/roblox.d.ts",
	name = "@rbxts/types",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/roblox-ts/types.git",
	},
	scripts = {
	},
	types = "include/roblox.d.ts",
	version = "1.0.646",
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="ModuleScript" referent="RBX4915D5D2084A4957A3E8F05F97AD100C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">radio</string>
			<string name="ScriptGuid">{B8BD3249-4623-499F-8FA1-9B93890CA4F3}</string>
			<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local TS = require(script.Parent.include.RuntimeLib)
-- THE FOLLOWING LIBRARY IS INCLUDED BECAUSE THIS HAS NOT BEEN FINALIZED ENOUGH TO BE A LIBRARY
-- However, it should be good enough for this particular case.
-- @author Validark
local Cue = TS.import(script, script.Parent, "include", "node_modules", "@rbxts", "cue")
local Linear = TS.import(script, script.Parent, "include", "node_modules", "@rbxts", "easing-functions").Linear
local Tween = TS.import(script, script.Parent, "include", "node_modules", "@rbxts", "tween").default
--[[
	*
	* Returns a table wherein an object's writable properties can be specified,
	* while also allowing functions to be passed in which can be bound to a Cue.
]]
local frames = {}
local FRAMES_PER_ANIMATION = 30
local ANIMATION_TIME = 0.25
local COLUMNS = 15
local DIMENSION_X = 36
local DIMENSION_Y = 36
local HOVER_FRAMES = 6
local HOVER_ANIMATION_TIME = 0.1
local OLD_IMAGES = {
	[0] = 3336269098,
	[2] = 3336269399,
	[4] = 3336269669,
	[8] = 3336269958,
}
local IMAGES = {
	[0] = 3336269098,
	[2] = 3336484156,
	[4] = 3336484351,
	[8] = 3336484559,
	[16] = 3336484747,
}
do
	local i = 0
	local _shouldIncrement = false
	while true do
		if _shouldIncrement then
			i += 1
		else
			_shouldIncrement = true
		end
		if not (i < 60) then
			break
		end
		frames[i + 1] = Vector2.new((i % COLUMNS) * DIMENSION_X, math.floor(i / COLUMNS) * DIMENSION_Y)
	end
end
local numCheckboxes = 0
local Canceler = {
	Running = false,
}
-- * A material design Checkbox element.
local Radio
do
	Radio = setmetatable({}, {
		__tostring = function()
			return "Radio"
		end,
	})
	Radio.__index = Radio
	function Radio.new(...)
		local self = setmetatable({}, Radio)
		return self:constructor(...) or self
	end
	function Radio:constructor(settings)
		self.currentTween = Canceler
		self.isHovering = false
		self.hoverFrame = 0
		self.isDisabled = false
		self.onChecked = Cue.new()
		local _binding = self
		local onChecked = _binding.onChecked
		local button = Instance.new("ImageButton")
		button.BackgroundTransparency = 1
		local _original = numCheckboxes
		numCheckboxes += 1
		button.Name = "Checkbox" .. tostring(_original)
		local check = Instance.new("ImageLabel")
		check.AnchorPoint = Vector2.new(0.5, 0.5)
		check.BackgroundTransparency = 1
		check.ImageRectSize = Vector2.new(36, 36)
		check.Position = UDim2.new(0.5, 0, 0.5, 0)
		check.Size = UDim2.new(0.75, 0, 0.75, 0)
		check.Parent = button
		self.button = button
		self.check = check
		local switchChecked = function()
			if not self:getChecked() then
				self:setChecked(not self.isChecked)
			end
		end
		local enterHoverState = function()
			self.isHovering = true
			if self.isChecked == false then
				if self.currentTween.Running then
					self.currentTween:Cancel()
				end
				self.currentTween = Tween(HOVER_ANIMATION_TIME, Linear, function(x)
					local _exp = self.check
					local _exp_1 = frames
					self.hoverFrame = math.floor(x + 0.5)
					_exp.ImageRectOffset = _exp_1[(self.hoverFrame) + 1]
					return _exp.ImageRectOffset
				end, self.hoverFrame % 7, HOVER_FRAMES)
			end
		end
		local exitHoverState = function()
			self.isHovering = false
			if self.isChecked == false then
				if self.currentTween.Running then
					self.currentTween:Cancel()
				end
				self.currentTween = Tween(HOVER_ANIMATION_TIME, Linear, function(x)
					local _exp = frames
					self.hoverFrame = math.floor(x + 0.5)
					check.ImageRectOffset = _exp[(self.hoverFrame) + 1]
					return check.ImageRectOffset
				end, self.hoverFrame % 7, 0)
			end
		end
		button.MouseEnter:Connect(enterHoverState)
		button.MouseLeave:Connect(exitHoverState)
		button.MouseButton1Click:Connect(switchChecked)
		if settings then
			local _binding_1 = settings
			local position = _binding_1.position
			local anchorPoint = _binding_1.anchorPoint
			self.isChecked = settings.isChecked
			self:setSize(settings.size or 24)
			self:setBorderRadius(if settings.borderRadius == nil then 2 else settings.borderRadius)
			self:setTheme(settings.theme or "Light")
			if position then
				button.Position = position
			end
			if anchorPoint then
				button.AnchorPoint = anchorPoint
			end
			button.Parent = settings.parent
			onChecked:bind(settings.onChecked)
			onChecked:go(settings.isChecked)
		else
			self.isChecked = false
			self:setSize(24)
			self:setBorderRadius(2)
			self:setTheme("Light")
		end
		delay(0.5, function()
			return self:setChecked(self.isChecked)
		end)
	end
	function Radio:getTheme()
		return if self.isLightTheme then "Light" else "Dark"
	end
	function Radio:setTheme(theme)
		self.isLightTheme = theme == "Light"
		local isLightTheme = (self.isLightTheme)
		if self.isChecked == false then
			local _binding = self
			local check = _binding.check
			check.ImageColor3 = if isLightTheme then Color3.fromRGB(0, 0, 0) else Color3.fromRGB(255, 255, 255)
			check.ImageTransparency = if isLightTheme then (if self.isDisabled then 0.74 else 0.46) elseif self.isDisabled then 0.7 else 0.3
		end
	end
	function Radio:getPosition()
		return self.button.Position
	end
	function Radio:setPosition(position)
		self.button.Position = position
	end
	function Radio:getSize()
		return self.button.Size.X.Offset
	end
	function Radio:setSize(size)
		self.button.Size = UDim2.new(0, size, 0, size)
	end
	function Radio:getBorderRadius()
		local assetId = tonumber(string.sub(self.check.Image, 13))
		for borderRadius, id in pairs(IMAGES) do
			if assetId == id then
				return borderRadius
			end
		end
		return 0
	end
	function Radio:setBorderRadius(borderRadius)
		self.check.Image = "rbxassetid://" .. tostring(IMAGES[borderRadius])
	end
	function Radio:getParent()
		return self.button.Parent
	end
	function Radio:setParent(parent)
		self.button.Parent = parent
	end
	function Radio:getAnchorPoint()
		return self.button.AnchorPoint
	end
	function Radio:setAnchorPoint(anchorPoint)
		self.button.AnchorPoint = anchorPoint
	end
	function Radio:destroy()
		self.onChecked:unbindAll()
		self.button:Destroy()
		self.check:Destroy()
	end
	function Radio:setChecked(isChecked)
		self.isChecked = isChecked
		self.onChecked:go(isChecked)
		local _binding = self
		local check = _binding.check
		if isChecked then
			check.ImageTransparency = 0
			check.ImageColor3 = Color3.fromRGB(0, 150, 136)
			if self.currentTween.Running then
				self.currentTween:Cancel()
			end
			self.currentTween = Tween(ANIMATION_TIME, Linear, function(x)
				local _exp = frames
				self.hoverFrame = math.floor(x + 0.5)
				check.ImageRectOffset = _exp[(self.hoverFrame) + 1]
				return check.ImageRectOffset
			end, if self.hoverFrame < 7 then self.hoverFrame else 0, FRAMES_PER_ANIMATION)
		else
			check.ImageTransparency = 0.46
			check.ImageColor3 = Color3.fromRGB(0, 0, 0)
			if self.currentTween.Running then
				self.currentTween:Cancel()
			end
			local currentTween = Tween(ANIMATION_TIME, Linear, function(x)
				local _exp = frames
				self.hoverFrame = math.floor(x + 0.5) % 60
				check.ImageRectOffset = _exp[(self.hoverFrame) + 1]
				return check.ImageRectOffset
			end, self.hoverFrame, 60 - (if self.isHovering then 0 else 0))
			-- currentTween.FinishCallback = finished => {
			-- if (finished) check.ImageRectOffset = frames[(this.hoverFrame = 6)];
			-- };
			self.currentTween = currentTween
		end
	end
	function Radio:getChecked()
		return self.isChecked
	end
	function Radio:clone()
		return Radio.new({
			isChecked = self.isChecked,
			position = self.button.Position,
			anchorPoint = self.button.AnchorPoint,
			size = self.button.Size.X.Offset,
			borderRadius = self:getBorderRadius(),
		})
	end
end
return Radio
]]></ProtectedString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
</roblox>